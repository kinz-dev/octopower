type AccountApplicationConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AccountApplicationConnectionTypeEdge]!
}

"""
A Relay edge containing a `AccountApplicationConnectionType` and its cursor.
"""
type AccountApplicationConnectionTypeEdge {
  """The item at the end of the edge"""
  node: AccountApplicationType

  """A cursor for use in pagination"""
  cursor: String!
}

"""An enumeration."""
enum AccountApplicationSalesChannel {
  """Direct"""
  DIRECT

  """Price comparison site"""
  PRICE_COMPARISON

  """Telesales"""
  TELESALES

  """Digital telesales"""
  DIGI_TELESALES

  """Events"""
  EVENTS

  """Field sales"""
  FIELD_SALES

  """Aggregator"""
  AGGREGATOR

  """Partnerships"""
  PARTNERSHIPS

  """New tenant"""
  NEW_TENANT

  """Move in"""
  MOVE_IN

  """Workplace pop-up"""
  WORKPLACE_POP_UP

  """Broker"""
  BROKER

  """Parent power"""
  PARENT_POWER

  """Supplier of last resort"""
  SUPPLIER_OF_LAST_RESORT

  """Acquisition"""
  ACQUISITION

  """Landlord"""
  LANDLORD
}

"""An enumeration."""
enum AccountApplicationStatus {
  """Current"""
  CURRENT

  """Failed"""
  FAILED

  """Historic"""
  HISTORIC
}

type AccountApplicationType {
  status: AccountApplicationStatus!
  salesChannel: AccountApplicationSalesChannel

  """
  The sales subchannel used when signing up. This could for example be a price comparison site.
  """
  salesSubchannel: String

  """Date at which this account decided to switch to us."""
  dateOfSale: Date

  """
  Last day of the cooling off period. Barring changes or objections, the account
  will be gained on the next business day after this date. This value will only
  be returned for current applications.
  """
  coolingOffEndDate: Date

  """
  Whether this account application represents a migration into the current system or a regular gain.
  """
  isMigrated: Boolean

  """
  The source system for a migrated account. This could be the previous supplier or the previous account management system.
  """
  migrationSource: String
}

"""An enumeration."""
enum AccountBillingOptionsPeriodLength {
  """Monthly"""
  MONTHLY

  """Quarterly"""
  QUARTERLY
}

type AccountCampaignType {
  """The name of the campaign."""
  name: String

  """The date that the campaign expires for the account."""
  expiryDate: Date
}

type AccountChargeMetadataType {
  data: JSONString!
  updatedAt: DateTime!
}

"""An enumeration."""
enum AccountChargeReason {
  """Balance transfer"""
  BALANCE_TRANSFER

  """SOLR balance transfer"""
  SOLR_BALANCE_TRANSFER

  """Balance transfer"""
  DATA_IMPORT_BALANCE_TRANSFER

  """Balance transfer for final billed account"""
  BALANCE_TRANSFER_FOR_FINAL_BILLED_ACCOUNT

  """Imported charge"""
  IMPORTED_CHARGE

  """Supplementary ledger balance transfer"""
  SUPPLEMENTARY_LEDGER_BALANCE_TRANSFER

  """Incorrect payment reversal"""
  INCORRECT_PAYMENT_REVERSAL

  """Refund"""
  REFUND

  """Reversed credit"""
  REVERSED_ACCOUNT_CREDIT

  """Outgoing Balance Transfer"""
  OUTGOING_BALANCE_TRANSFER

  """Adjusted credit to allow refund"""
  ADJUSTED_CREDIT_TO_ALLOW_REFUND

  """AC Adjustment"""
  AC_ADJUSTMENT

  """Nest Learning Thermostat rental"""
  NEST_LEARNING_THERMOSTAT_RENTAL

  """Business advance payment"""
  BUSINESS_ADVANCE_PAYMENT

  """Prepay balance adjustment"""
  PREPAY_BALANCE_ADJUSTMENT

  """Feed-in-Tariff payment transfer to nominated recipient"""
  FEED_IN_TARIFF_PAYMENT_TRANSFER_TO_NOMINATED_RECIPIENT

  """Service order"""
  SERVICE_ORDER

  """Custom"""
  CUSTOM

  """Automatic Reconciliation"""
  AUTO_RECONCILIATION

  """Default"""
  DEFAULT

  """Balance transfer for final billed account"""
  BALANCE_TRANSFER_FOR_FINAL_BILLED_ACCOUNT_20

  """Credit balance donated to charity"""
  CREDIT_BALANCE_DONATED_TO_CHARITY

  """Direct debit refund balancing"""
  DIRECT_DEBIT_REFUND_BALANCING

  """Metering Job: Business"""
  METERING_JOB_BUSINESS

  """Metering Job: National Grid"""
  METERING_JOB_NATIONAL_GRID

  """Metering Job: SMS"""
  METERING_JOB_SMS

  """Penalty charge"""
  PENALTY_CHARGE

  """Prepay debt adjustment"""
  PREPAY_DEBT_ADJUSTMENT

  """Business prepayment (deprecated)"""
  BUSINESS_PREPAYMENT

  """Write back"""
  WRITE_BACK

  """Early exit fee"""
  EARLY_EXIT_FEE

  """DCA charge"""
  DCA_CHARGE

  """Green Deal charge"""
  GREEN_DEAL_CHARGE

  """Water"""
  WATER

  """Paper bill fee"""
  PAPER_BILL_FEE

  """Over the counter payment fee"""
  OVER_THE_COUNTER_PAYMENT_FEE

  """Carbon offset charge"""
  CARBON_OFFSET
}

"""

    Please note: these labels are exposed in the API documentation.
    
"""
enum AccountChargeReasonType {
  """Default"""
  DEFAULT
}

type AccountChargeType {
  id: ID!
  grossAmount: Int!

  """Climate change levy"""
  cclAmount: Int!
  netAmount: Int
  salesTaxAmount: Int
  reason: AccountChargeReason
  note: String!
  metadata: AccountChargeMetadataType
}

type AccountCreditMetadataType {
  data: JSONString!
  updatedAt: DateTime!
}

"""An enumeration."""
enum AccountCreditReason {
  """Additional standard payment"""
  ADDITIONAL_STANDARD_PAYMENT

  """Balance adjustment"""
  BALANCE_ADJUSTMENT

  """Balance transfer"""
  BALANCE_TRANSFER

  """Bank transfer"""
  BANK_TRANSFER

  """Customer reimbursement"""
  CUSTOMER_REIMBURSEMENT

  """Disputed card payments"""
  DISPUTED_CARD_PAYMENTS

  """Imported credit"""
  IMPORTED_CREDIT

  """Market research club reward"""
  MARKET_RESEARCH_CLUB_REWARD

  """Offset"""
  OFFSET

  """Prepay debt adjustment"""
  PREPAY_DEBT_ADJUSTMENT

  """ReferralCandy incentive"""
  REFERRALCANDY_INCENTIVE

  """Reinstated direct debit"""
  REINSTATED_DIRECT_DEBIT

  """SOLR balance transfer"""
  SOLR_BALANCE_TRANSFER

  """Balance transfer"""
  DATA_IMPORT_BALANCE_TRANSFER

  """Balance transfer for final billed account"""
  BALANCE_TRANSFER_FOR_FINAL_BILLED_ACCOUNT

  """SOLR write off"""
  SOLR_WRITE_OFF

  """SOLR ex-customer credit"""
  SOLR_EX_CUSTOMER_CREDIT

  """Supplementary ledger balance transfer"""
  SUPPLEMENTARY_LEDGER_BALANCE_TRANSFER

  """Member share of profits"""
  SHARE_OF_PROFITS

  """Goodwill payment"""
  GOODWILL_PAYMENT

  """Deposit refund"""
  DEPOSIT_REFUND

  """Go Cardless chargeback cancelled"""
  GO_CARDLESS_CHARGEBACK_CANCELLED

  """Cheque payment received"""
  CHEQUE_PAYMENT_RECEIVED

  """GSS failure"""
  GSS_FAILURE

  """Erroneous transfer refund"""
  ERRONEOUS_TRANSFER_REFUND

  """Waive termination fees"""
  WAIVE_TERMINATION_FEES

  """Adjusted credit to allow refund"""
  ADJUSTED_CREDIT_TO_ALLOW_REFUND

  """Direct debit bank charge - May"""
  DIRECT_DEBIT_BANK_CHARGE_MAY

  """Gas off supply payment"""
  GAS_OFF_SUPPLY_PAYMENT

  """Honoured bank charges"""
  HONOURED_BANK_CHARGES

  """Management waived fees"""
  MANAGEMENT_WAIVED_FEES

  """Closed reversion"""
  CLOSED_REVERSION

  """GSS failure MOP"""
  GSS_FAILURE_MOP

  """GSS Affect"""
  GSS_AFFECT

  """Reversioned post DD canx"""
  REVERSIONED_POST_DD_CANX

  """Incoming payment Go Cardless"""
  INCOMING_PAYMENT_GO_CARDLESS

  """Debit balance transfer"""
  DEBIT_BALANCE_TRANSFER

  """Received via credit style"""
  RECEIVED_VIA_CREDIT_STYLE

  """Tariff price adjustment - Goodwill"""
  TARIFF_PRICE_ADJUSTMENT_GOODWILL

  """Economy 7 difference"""
  ECONOMY_7_DIFFERENCE

  """Back Billing Write Off"""
  WRITE_OFF_BACK_BILLING

  """Write off (past billable date)"""
  WRITE_OFF_PAST_BILLABLE_AUTOMATED

  """Write off (missed payment deletion)"""
  WRITE_OFF_MISSED_DELETION

  """Tariff Discount"""
  TARIFF_DISCOUNT

  """Returned business advance payment"""
  RETURNED_BUSINESS_ADVANCE_PAYMENT

  """Custom"""
  CUSTOM

  """Standards of performance (general ET)"""
  STANDARDS_OF_PERFORMANCE_ERRONEOUS_TRANSFER

  """Additional SoP payment (general ET)"""
  ADDITIONAL_SOP_PAYMENT_ERRONEOUS_TRANSFER

  """External referral credit"""
  EXTERNAL_REFERRAL_CREDIT

  """Standards of performance payments"""
  STANDARDS_OF_PERFORMANCE_PAYMENTS

  """Disc - Warm Home Discount"""
  DISC_WARM_HOME_DISCOUNT

  """Payment - Auspost"""
  PAYMENT_AUSPOST

  """Payment - IVR"""
  PAYMENT_IVR

  """Payment - EAPA Voucher"""
  PAYMENT_EAPA_VOUCHER

  """Payment - Cheque"""
  PAYMENT_CHEQUE

  """Payment - BPAY"""
  PAYMENT_BPAY

  """Payment - Credit Card"""
  PAYMENT_CREDIT_CARD

  """Payment - Centrepay"""
  PAYMENT_CENTREPAY

  """Payment - Bank Account"""
  PAYMENT_BANK_ACCOUNT

  """Accuracy test results - balance adjustment"""
  ACCURACY_TEST_ADJUSTMENT

  """Customer service gesture"""
  CUSTOMER_SERVICE_GESTURE

  """Exit fee refund"""
  EXIT_FEE_REFUND

  """Feed-in Tariff payment"""
  FEED_IN_TARIFF_PAYMENT

  """Gas network compensation"""
  GAS_NETWORK_COMPENSATION

  """Joining reward"""
  JOINING_REWARD

  """Loyalty reward"""
  LOYALTY_REWARD

  """Missed savings"""
  MISSED_SAVINGS

  """Referral reward"""
  REFERRAL_REWARD

  """Returned business prepayment (deprecated)"""
  RETURNED_BUSINESS_PREPAYMENT

  """Sales compensation"""
  SALES_COMPENSATION

  """Export tariff payment"""
  EXPORT_TARIFF_PAYMENT

  """Write off (bankruptcy)"""
  WRITE_OFF_BANKRUPTCY

  """Write off (deceased)"""
  WRITE_OFF_DECEASED

  """Write off (DRO)"""
  WRITE_OFF_DRO

  """Write off (IVA)"""
  WRITE_OFF_IVA

  """Write off (negligible value)"""
  WRITE_OFF_NEGLIGIBLE_VALUE

  """Write off (unrecoverable debt)"""
  WRITE_OFF_UNRECOVERABLE_DEBT

  """Write off (past billable date)"""
  WRITE_OFF_PAST_BILLABLE

  """Write off (recovery discount)"""
  WRITE_OFF_RECOVERY_DISCOUNT

  """Withdrawal not actioned"""
  WITHDRAWAL_NOT_ACTIONED

  """Staff Discount"""
  STAFF_DISCOUNT

  """Direct Debit Discount"""
  DIRECT_DEBIT_DISCOUNT

  """Reverse energy charge"""
  REVERSE_ENERGY_CHARGE

  """Reversed account charge"""
  REVERSED_ACCOUNT_CHARGE

  """Warm home discount - Broader group"""
  WARM_HOME_DISCOUNT_BROADER_GROUP

  """Warm home discount - Core group"""
  WARM_HOME_DISCOUNT_CORE_GROUP

  """Standards of performance (ET comms overdue)"""
  STANDARDS_OF_PERFORMANCE_ET_COMMS_OVERDUE

  """Standards of performance (ET loss unresolved)"""
  STANDARDS_OF_PERFORMANCE_ET_LOSS_UNRESOLVED

  """Standards of performance (ET gain unresolved)"""
  STANDARDS_OF_PERFORMANCE_ET_GAIN_UNRESOLVED

  """Standards of performance (Customer not returned)"""
  STANDARDS_OF_PERFORMANCE_CUSTOMER_NOT_RETURNED

  """Standards of performance (ET gain accepted)"""
  STANDARDS_OF_PERFORMANCE_ET_GAIN_ACCEPTED

  """Additional SoP payment (ET comms overdue)"""
  ADDITIONAL_SOP_PAYMENT_ET_COMMS_OVERDUE

  """Additional SoP payment (ET loss unresolved)"""
  ADDITIONAL_SOP_PAYMENT_ET_LOSS_UNRESOLVED

  """Additional SoP payment (ET gain unresolved)"""
  ADDITIONAL_SOP_PAYMENT_ET_GAIN_UNRESOLVED

  """Additional SoP payment (customer not returned)"""
  ADDITIONAL_SOP_PAYMENT_CUSTOMER_NOT_RETURNED

  """Additional SoP payment (ET gain accepted"""
  ADDITIONAL_SOP_PAYMENT_ET_GAIN_ACCEPTED

  """Standard of performance (electricity standard visit)"""
  STANDARDS_OF_PERFORMANCE_APPOINTMENTS_STANDARD_VISIT_ELEC

  """Standard of performance (electricity faulty meter resolution overdue)"""
  STANDARDS_OF_PERFORMANCE_APPOINTMENTS_FAULTY_METER_ELEC

  """Standard of performance (electricity prepay meter resolution overdue)"""
  STANDARDS_OF_PERFORMANCE_APPOINTMENTS_PREPAY_METER_ELEC

  """Standard of performance (electricity reconnection overdue)"""
  STANDARDS_OF_PERFORMANCE_APPOINTMENTS_RECONNECTION_ELEC

  """
  Standard of performance (electricity failure to switch in 15 working days)
  """
  STANDARDS_OF_PERFORMANCE_LATE_SWITCH_ELEC

  """Single rate RMI"""
  SINGLE_RATE_RMI

  """Additional SoP (electricity switch delayed)"""
  ADDITIONAL_SOP_PAYMENT_ELECTRICITY_SWITCH_DELAYED

  """Standard of performance (gas standard visit)"""
  STANDARDS_OF_PERFORMANCE_APPOINTMENTS_STANDARD_VISIT_GAS

  """Standard of performance (gas faulty meter resolution overdue)"""
  STANDARDS_OF_PERFORMANCE_APPOINTMENTS_FAULTY_METER_GAS

  """Standard of performance (gas prepay meter resolution overdue)"""
  STANDARDS_OF_PERFORMANCE_APPOINTMENTS_PREPAY_METER_GAS

  """Standard of performance (gas reconnection overdue)"""
  STANDARDS_OF_PERFORMANCE_APPOINTMENTS_RECONNECTION_GAS

  """Standard of performance (gas failure to switch in 15 working days)"""
  STANDARDS_OF_PERFORMANCE_LATE_SWITCH_GAS

  """Standard of performance (final bill refund overdue)"""
  STANDARDS_OF_PERFORMANCE_REFUND_ISSUED_LATE

  """Standard of performance (final bill overdue)"""
  STANDARDS_OF_PERFORMANCE_FINAL_BILL_ISSUED_LATE

  """Additional SoP payment (appointments)"""
  ADDITIONAL_SOP_PAYMENT_APPOINTMENTS

  """Payment - Transfer from SAP"""
  PAYMENT_TRANSFER_FROM_SAP

  """NSW family energy rebate"""
  NSW_FAMILY_ENERGY_REBATE

  """NSW Government Gas Rebate"""
  NSW_GOVERNMENT_GAS_REBATE

  """NSW Gvt Household rebate (Inc GST)"""
  NSW_GOVERNMENT_HOUSEHOLD_REBATE

  """NSW government life support rebate"""
  NSW_GOVERNMENT_LIFE_SUPPORT_REBATE

  """NSW medical energy rebate"""
  NSW_MEDICAL_ENERGY_REBATE

  """QLD Government Electricity Rebate"""
  QLD_GOVERNMENT_ELECTRICITY_REBATE

  """QLD Government Gas Rebate"""
  QLD_GOVERNMENT_GAS_REBATE

  """QLD Asset Ownership Dividend"""
  QLD_ASSET_OWNERSHIP_DIVIDEND

  """SA Government Energy Concession"""
  SA_GOVERNMENT_ENERGY_CONCESSION

  """SME reversed pre-migration charge"""
  SME_REVERSED_PRE_MIGRATION_CHARGE

  """VIC Government Annual electricity concession"""
  VIC_GOVERNMENT_ANNUAL_ELECTRICITY_CONCESSION

  """VIC Government Controlled load electricity concession"""
  VIC_GOVERNMENT_CONTROLLED_LOAD_CONCESSION

  """VIC Government Excess electricity concession"""
  VIC_GOVERNMENT_EXCESS_ELECTRICITY_CONCESSION

  """VIC Government Life support concession"""
  VIC_GOVERNMENT_LIFE_SUPPORT_CONCESSION

  """VIC Government Medical cooling concession"""
  VIC_GOVERNMENT_MEDICAL_COOLING_CONCESSION

  """VIC Government Service to property charge concession"""
  VIC_GOVERNMENT_SERVICE_TO_PROPERTY_CONCESSION
}

"""

    Please note: these labels are exposed in the API documentation.
    
"""
enum AccountCreditReasonType {
  """External referral credit"""
  EXTERNAL_REFERRAL_CREDIT
}

type AccountCreditType {
  id: ID!
  grossAmount: Int!
  netAmount: Int!
  salesTaxAmount: Int!
  note: String!
  reason: AccountCreditReason!
  metadata: AccountCreditMetadataType
}

union AccountEvent = EmailEventType

type AccountEventConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AccountEventConnectionTypeEdge]!
}

"""A Relay edge containing a `AccountEventConnectionType` and its cursor."""
type AccountEventConnectionTypeEdge {
  """The item at the end of the edge"""
  node: AccountEvent

  """A cursor for use in pagination"""
  cursor: String!
}

"""An enumeration."""
enum AccountEventType {
  """The email messages that were sent by the account."""
  EMAIL_SENT

  """The email messages that were received by the account."""
  EMAIL_RECEIVED
}

type AccountFileAttachment implements Node & FileAttachment {
  """The ID of the object."""
  id: ID!
  filename: String!
  category: String!

  """Is the file uploaded to S3?"""
  isUploaded: Boolean

  """Is the file ready for use / downloadable?"""
  isReady: Boolean
  fetchUrl: String
  sizeInBytes: Int
}

interface AccountInterface {
  """The current status of the account"""
  status: AccountStatus

  """The current account balance."""
  balance: Int

  """Unique reference number from a 3rd party enrolment."""
  urn: String

  """The billing name of the account."""
  billingName: String

  """The billing address of the account."""
  billingAddress: String
  billingAddressLine1: String
  billingAddressLine2: String
  billingAddressLine3: String
  billingAddressLine4: String
  billingAddressLine5: String
  billingAddressPostcode: String
  billingCountryCode: String
  billingDeliveryPointIdentifier: String

  """List of billing address lines."""
  splitBillingAddress: [String]

  """
  
  **⚠️ This field is currently in preview. During this time,
  it may change without warning in backwards-incompatible
  ways.**
  
  The billing address of this account, stored in the new
  libaddressinput-based format.
  
  Note that `name` and `organization` are very unlikely to be
  supplied here; the `billing_name` field on the account
  itself is generally used for that purpose instead.
  
  """
  address: RichAddressType

  """A code that uniquely identifies the account."""
  number: String

  """
  Ledgers provide the foundation of bookkeeping functionality. Similar to a bank
  account, they allow us to keep track of financial activity on a particular
  customer account.
  """
  ledgers: [LedgerType]

  """Whether the account can request a credit refund."""
  canRequestRefund: Boolean

  """The payments made into an account from a payment instruction."""
  payments(status: AccountPaymentStatusOptions, before: String, after: String, first: Int, last: Int): AccountPaymentConnectionTypeConnection

  """The repayments that have been requested for this account."""
  repayments(
    """Only return repayments whose status matches one of these statuses"""
    statuses: [AccountRepaymentStatusOptions]
    before: String
    after: String
    first: Int
    last: Int
  ): AccountRepaymentConnectionTypeConnection

  """
  The schedules that describe how we would expect to take payments for an account on a given month.
  """
  paymentSchedules(
    activeOnDate: Date
    active: Boolean
    canCreatePayment: Boolean

    """The ledger to return transactions from."""
    ledgerType: Int
    reason: PaymentScheduleReasonOptions
    before: String
    after: String
    first: Int
    last: Int
  ): PaymentScheduleConnectionTypeConnection

  """
  A list displaying the payment forecast for an account. The list starts from today's date (inclusive).
  """
  paymentForecast(
    """The end date to retrieve forecasts for. This end date is inclusive."""
    dateTo: Date!

    """
    The ledger to return payment forecasts from. Defaults to the main ledger when no ID is passed.
    """
    ledgerId: Int
  ): [PaymentForecastType]

  """The referrals created by this account."""
  referrals(before: String, after: String, first: Int, last: Int): ReferralConnectionTypeConnection

  """The referral schemes currently active for this account."""
  activeReferralSchemes: ReferralSchemeTypes

  """Fetch transactions that have taken place on the account."""
  transactions(
    """Return these transaction types only."""
    transactionTypes: [TransactionTypeFilter] = []

    """The ledger to return transactions from."""
    ledgerId: Int
    before: String
    after: String
    first: Int
    last: Int
  ): TransactionConnectionTypeConnection
  provisionalTransactions(before: String, after: String, first: Int, last: Int): ProvisionalTransactionConnectionTypeConnection

  """Fetch annual statements for the account."""
  annualStatements(before: String, after: String, first: Int, last: Int): AnnualStatementConnectionTypeConnection

  """Fetch issued bills (invoices/statements) for the account."""
  bills(
    """Include bills without PDFs"""
    includeBillsWithoutPDF: Boolean = false

    """
    
    Include open statements. This flag needs to be used along with
    includeBillsWithoutPDF=false otherwise results will prove unexpected.
    
    """
    includeOpenStatements: Boolean = false

    """Only include bills emailed to the current user's email"""
    onlyCurrentEmail: Boolean = false
    before: String
    after: String
    first: Int
    last: Int
  ): BillConnectionTypeConnection

  """Information about the account's billing cycle."""
  billingOptions: BillingOptionsType

  """Fetch a specific issued bill (invoice/statement) for the account."""
  bill(id: ID, billType: BillTypeEnum): BillInterface

  """The direct debit instructions of the account"""
  directDebitInstructions(
    """Filter the direct debit instructions by status"""
    statuses: [DirectDebitInstructionStatus]
    before: String
    after: String
    first: Int
    last: Int
  ): DirectDebitInstructionConnectionTypeConnection

  """The account events that were recorded for the account."""
  events(
    """Filter the account events by their type."""
    eventTypes: [AccountEventType]
    before: String
    after: String
    first: Int
    last: Int
  ): AccountEventConnectionTypeConnection

  """
  Applications by this account to become our customer. More recent applications will be listed first.
  """
  applications(before: String, after: String, first: Int, last: Int): AccountApplicationConnectionTypeConnection

  """The type of account."""
  accountType: AccountTypeChoices

  """The method the account has specified they prefer we contact them"""
  commsDeliveryPreference: CommsDeliveryPreference
  communicationDeliveryPreference: String @deprecated(reason: "Use `commsDeliveryPreference` instead")

  """Account references linked to this account."""
  references: [AccountReferenceType]

  """
  Files attached to this account. Only available if categories defined in settings.
  """
  fileAttachments: [AccountFileAttachment]

  """
  The maximum amount a customer is allowed to request as a refund and the reason why that's the maximum amount.
  """
  maximumRefund: MaximumRefundType

  """The campaigns associated with an account."""
  campaigns: [AccountCampaignType]
}

input AccountNumberInput {
  """Account number."""
  accountNumber: String!
}

type AccountPaymentConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AccountPaymentConnectionTypeEdge]!
}

"""
A Relay edge containing a `AccountPaymentConnectionType` and its cursor.
"""
type AccountPaymentConnectionTypeEdge {
  """The item at the end of the edge"""
  node: AccountPaymentType

  """A cursor for use in pagination"""
  cursor: String!
}

"""An enumeration."""
enum AccountPaymentStatusOptions {
  """
  The payment has been scheduled for collection and the customer has been
  notified. While a payment is scheduled, it can still be deleted.
  """
  SCHEDULED

  """The payment has been submitted. From this point it cannot be altered."""
  PENDING

  """
  The payment has been approved by the merchant and added to your Kraken account.
  """
  CLEARED

  """The payment failed permanently."""
  FAILED

  """
  A payment promise has been created, but it has not left the customers bank account.
  """
  PROMISED

  """
  The payment has been made successfully and applied to the Kraken balance.
  """
  FULFILLED

  """The payment promise has been broken."""
  PROMISE_BROKEN

  """Payments made in a previous system and then imported into Kraken."""
  HISTORIC

  """
  Third Party payments are those recorded for financial purposes in a different system but should be added to statements.
  """
  THIRD_PARTY

  """
  The initial state of a payment in Kraken. It should be scheduled with a payment vendor in the future.
  """
  REQUESTED
}

type AccountPaymentType {
  id: ID!

  """Amount of payment in pence"""
  amount: Int!

  """The date this payment is scheduled to be debited"""
  paymentDate: Date!
  reference: String!
  transactionType: String!

  """The current status of the payment"""
  status: AccountPaymentStatusOptions

  """Surchage amount generated by this payment."""
  surchargeAmount: Int
}

"""The input type for the account reference."""
input AccountReferenceInput {
  """The account number."""
  accountNumber: String!

  """The namespace for the reference."""
  namespace: String!

  """The reference value."""
  value: String!
}

type AccountReferenceType {
  account: AccountType!
  namespace: String!

  """The unique identifier for the account."""
  value: String!

  """When this was created in our database."""
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AccountRepaymentConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AccountRepaymentConnectionTypeEdge]!
}

"""
A Relay edge containing a `AccountRepaymentConnectionType` and its cursor.
"""
type AccountRepaymentConnectionTypeEdge {
  """The item at the end of the edge"""
  node: AccountRepaymentType

  """A cursor for use in pagination"""
  cursor: String!
}

"""An enumeration."""
enum AccountRepaymentStatusOptions {
  """The request for a repayment has been received but not actioned yet."""
  REQUESTED

  """The repayment has been approved but not made yet."""
  APPROVED

  """
  The payment has been submitted to the merchant. It is still possible for this repayment to fail.
  """
  SUBMITTED

  """
  The repayment failed permanently. This could be because of technical issues,
  or if the merchant rejects the payment for some reason. The payment will need
  to be retried by ops.
  """
  FAILED

  """
  The repayment has been made to the merchant to be sent to the customer. This
  is a terminal state, we don't get any further confirmation.
  """
  PAID

  """
  Third Party payments are those recorded for financial purposes in a different system but should be added to statements.
  """
  THIRD_PARTY

  """Payments made in a previous system and then imported into Kraken."""
  HISTORIC
}

type AccountRepaymentType {
  id: ID!

  """Amount of payment in pence"""
  amount: Int!

  """The date this payment is scheduled to be debited"""
  paymentDate: Date!

  """The current status of the repayment"""
  status: AccountRepaymentStatusOptions
}

enum AccountStatus {
  """
  A pending account is one that has been created but no registrations have started.
  """
  PENDING

  """Account requires processes to be completed before supply can be set up"""
  INCOMPLETE

  """Withdrawn before supply started"""
  WITHDRAWN

  """Supply could have started, be ongoing or ended."""
  ACTIVE

  """
  An error occurred when we tried to enroll a meter point. This may be
  deprecated in future in favour of exposing this through enrollment property of a meter point.
  """
  ENROLMENT_ERROR

  """
  Meter point enrollment was rejected. This may be deprecated in future in
  favour of exposing this through enrollment property of a meter point.
  """
  ENROLMENT_REJECTED

  """Dormant. Users should not be able to log into dormant accounts."""
  DORMANT
}

"""An enumeration."""
enum AccountStatusChoices {
  """
  A pending account is one that has been created but no registrations have started.
  """
  PENDING

  """Account requires processes to be completed before supply can be set up"""
  INCOMPLETE

  """Withdrawn before supply started"""
  WITHDRAWN

  """Supply could have started, be ongoing or ended."""
  ACTIVE

  """
  An error occurred when we tried to enroll a meter point. This may be
  deprecated in future in favour of exposing this through enrollment property of a meter point.
  """
  ENROLMENT_ERROR

  """
  Meter point enrollment was rejected. This may be deprecated in future in
  favour of exposing this through enrollment property of a meter point.
  """
  ENROLMENT_REJECTED

  """Dormant. Users should not be able to log into dormant accounts."""
  DORMANT
}

"""
The account object can be one of several attached to a `Portfolio` (which
usually has an `AccountUser` which is used to authenticate access to the
`Portfolio`'s accounts). Typically a person has a single account attached to a
portfolio and properties on the same account will appear on the same bill. Where
separate bills are desired, multiple accounts  are created and added to the same
portfolio of accounts.
"""
type AccountType implements AccountInterface {
  id: ID!

  """A code that uniquely identifies the account."""
  number: String

  """The current status of the account"""
  status: AccountStatus

  """
  The schedules that describe how we would expect to take payments for an account on a given month.
  """
  paymentSchedules(
    activeOnDate: Date
    active: Boolean
    canCreatePayment: Boolean

    """The ledger to return transactions from."""
    ledgerType: Int
    reason: PaymentScheduleReasonOptions
    before: String
    after: String
    first: Int
    last: Int
  ): PaymentScheduleConnectionTypeConnection
  users: [AccountUserType!]!

  """The current account balance."""
  balance: Int

  """Unique reference number from a 3rd party enrolment."""
  urn: String

  """The billing name of the account."""
  billingName: String

  """The billing address of the account."""
  billingAddress: String
  billingAddressLine1: String
  billingAddressLine2: String
  billingAddressLine3: String
  billingAddressLine4: String
  billingAddressLine5: String
  billingAddressPostcode: String
  billingCountryCode: String
  billingDeliveryPointIdentifier: String

  """List of billing address lines."""
  splitBillingAddress: [String]

  """
  
  **⚠️ This field is currently in preview. During this time,
  it may change without warning in backwards-incompatible
  ways.**
  
  The billing address of this account, stored in the new
  libaddressinput-based format.
  
  Note that `name` and `organization` are very unlikely to be
  supplied here; the `billing_name` field on the account
  itself is generally used for that purpose instead.
  
  """
  address: RichAddressType

  """
  Ledgers provide the foundation of bookkeeping functionality. Similar to a bank
  account, they allow us to keep track of financial activity on a particular
  customer account.
  """
  ledgers: [LedgerType]

  """Whether the account can request a credit refund."""
  canRequestRefund: Boolean

  """The payments made into an account from a payment instruction."""
  payments(status: AccountPaymentStatusOptions, before: String, after: String, first: Int, last: Int): AccountPaymentConnectionTypeConnection

  """The repayments that have been requested for this account."""
  repayments(
    """Only return repayments whose status matches one of these statuses"""
    statuses: [AccountRepaymentStatusOptions]
    before: String
    after: String
    first: Int
    last: Int
  ): AccountRepaymentConnectionTypeConnection

  """
  A list displaying the payment forecast for an account. The list starts from today's date (inclusive).
  """
  paymentForecast(
    """The end date to retrieve forecasts for. This end date is inclusive."""
    dateTo: Date!

    """
    The ledger to return payment forecasts from. Defaults to the main ledger when no ID is passed.
    """
    ledgerId: Int
  ): [PaymentForecastType]

  """The referrals created by this account."""
  referrals(before: String, after: String, first: Int, last: Int): ReferralConnectionTypeConnection

  """The referral schemes currently active for this account."""
  activeReferralSchemes: ReferralSchemeTypes

  """Fetch transactions that have taken place on the account."""
  transactions(
    """Return these transaction types only."""
    transactionTypes: [TransactionTypeFilter] = []

    """The ledger to return transactions from."""
    ledgerId: Int
    before: String
    after: String
    first: Int
    last: Int
  ): TransactionConnectionTypeConnection
  provisionalTransactions(before: String, after: String, first: Int, last: Int): ProvisionalTransactionConnectionTypeConnection

  """Fetch annual statements for the account."""
  annualStatements(before: String, after: String, first: Int, last: Int): AnnualStatementConnectionTypeConnection

  """Fetch issued bills (invoices/statements) for the account."""
  bills(
    """Include bills without PDFs"""
    includeBillsWithoutPDF: Boolean = false

    """
    
    Include open statements. This flag needs to be used along with
    includeBillsWithoutPDF=false otherwise results will prove unexpected.
    
    """
    includeOpenStatements: Boolean = false

    """Only include bills emailed to the current user's email"""
    onlyCurrentEmail: Boolean = false
    before: String
    after: String
    first: Int
    last: Int
  ): BillConnectionTypeConnection

  """Information about the account's billing cycle."""
  billingOptions: BillingOptionsType

  """Fetch a specific issued bill (invoice/statement) for the account."""
  bill(id: ID, billType: BillTypeEnum): BillInterface

  """The direct debit instructions of the account"""
  directDebitInstructions(
    """Filter the direct debit instructions by status"""
    statuses: [DirectDebitInstructionStatus]
    before: String
    after: String
    first: Int
    last: Int
  ): DirectDebitInstructionConnectionTypeConnection

  """The account events that were recorded for the account."""
  events(
    """Filter the account events by their type."""
    eventTypes: [AccountEventType]
    before: String
    after: String
    first: Int
    last: Int
  ): AccountEventConnectionTypeConnection

  """
  Applications by this account to become our customer. More recent applications will be listed first.
  """
  applications(before: String, after: String, first: Int, last: Int): AccountApplicationConnectionTypeConnection

  """The type of account."""
  accountType: AccountTypeChoices

  """The method the account has specified they prefer we contact them"""
  commsDeliveryPreference: CommsDeliveryPreference
  communicationDeliveryPreference: String @deprecated(reason: "Use `commsDeliveryPreference` instead")

  """Account references linked to this account."""
  references: [AccountReferenceType]

  """
  Files attached to this account. Only available if categories defined in settings.
  """
  fileAttachments: [AccountFileAttachment]

  """
  The maximum amount a customer is allowed to request as a refund and the reason why that's the maximum amount.
  """
  maximumRefund: MaximumRefundType

  """The campaigns associated with an account."""
  campaigns: [AccountCampaignType]

  """Expected balance in a year's time"""
  projectedBalance: Int

  """Whether the account's payment should be adjusted."""
  shouldReviewPayments: Boolean

  """Top up payment amount in pence that we recommend for an account."""
  recommendedBalanceAdjustment: Int

  """Properties linked to the account now and in the future"""
  properties(
    """
    ('Returns properties that have an effective period that ends at or ', 'after the given activeFrom datetime.')
    """
    activeFrom: DateTime
  ): [PropertyType]

  """The electricity agreements belonging to the account"""
  electricityAgreements(active: Boolean): [ElectricityAgreementType]

  """The gas agreements belonging to the account"""
  gasAgreements(active: Boolean): [GasAgreementType]

  """Get details about warm home discount applications and records"""
  warmHomeDiscount: WarmHomeDiscount

  """The postcode of the billing address."""
  billingPostcode: String

  """Whether the account is eligible for tariff renewal"""
  canRenewTariff: Boolean

  """
  Only relevant for Kraken instances that support daily tracker tariffs. Returns null if not applicable. 
  """
  trackerTariffDailyPricing: TrackerTariffDailyPricing

  """Results of the latest review of the account's payments."""
  paymentAdequacy: PaymentAdequacyType

  """The interest of an account in procuring smart meters."""
  smets2Interest: SmartMeterInterestChoices

  """
  The reason why the account holder is not interested in having a smart meter installed.
  """
  smets2RefusalReason: SMETS2InterestReason

  """The green benefits achieved over the lifetime of an account."""
  greenAccomplishments: GreenAccomplishmentsType

  """Whether an account can change their payment schedule."""
  canChangePayments: Boolean

  """
  The number of days around a move out a final meter reading can be given for.
  """
  cotReadingWindowDays: Int
}

"""An enumeration."""
enum AccountTypeChoices {
  """An account designed to supply/bill business premises."""
  BUSINESS

  """An account designed to supply/bill domestic premises."""
  DOMESTIC

  """
  An account created when we supply a business premises but do not have details for the occupants.
  """
  BUSINESS_OCCUPIER

  """
  An account created when we supply a domestic premises but do not have details for the occupants.
  """
  OCCUPIER
}

type AccountUrl {
  urlIdentifier: String
  url: String
}

"""Information about the preferences set up for a user."""
type AccountUserCommsPreferences {
  """
  Whether a user has opted in to receive messages from the client or client
  group. For example, for Octopus Energy this describes whether a user is opted
  in to offers from Octopus Investments.
  """
  isOptedInToClientMessages: Boolean

  """
  Whether a user has opted in to receive messages offering discounts or other
  servicesnot directly related to the services the client provides.
  """
  isOptedInToOfferMessages: Boolean

  """
  Whether a user has opted in to receive messages we recommend they read, but
  are not vital to the utilities the client provides. For example, these could
  be reminders that the client will take a payment.
  """
  isOptedInToRecommendedMessages: Boolean

  """
  Whether a user has opted in to receive messages updating them on client activities.
  """
  isOptedInToUpdateMessages: Boolean

  """
  Whether a user has opted in to receive messages from the client's preferred third parties.
  """
  isOptedInToThirdPartyMessages: Boolean

  """What format the user would like to receive their emails in."""
  emailFormat: EmailFormats

  """
  Whether a user has opted to have inverted colours in their emails. This is
  currently only relevant to the Octopus Energy brand, whose emails have a dark
  background by default.
  """
  isUsingInvertedEmailColours: Boolean

  """
  This setting allows the user to adjust the default font size of the communications sent to them.
  """
  fontSizeMultiplier: Float

  """
  Whether the user has opted in to receive meter reading confirmation emails.
  """
  isOptedInMeterReadingConfirmations: Boolean

  """Whether the user has opted in to receive SMS messages."""
  isOptedInToSmsMessages: Boolean

  """Song which will be used as hold music for the user."""
  preferredHoldMusic: Songs
}

input AccountUserInput {
  givenName: String!
  familyName: String!
  email: String!
  mobile: String!
  optedInForMarketing: Boolean!
}

"""
User objects are the core of the authentication system. They typically represent
a customer who manages a portfolio of one or more accounts.
"""
type AccountUserType {
  id: ID!
  accounts: [AccountInterface]
  givenName: String!
  familyName: String!
  email: String!
  mobile: String!
  landline: String!

  """
  How this person wants us to refer to them in the third person, e.g. 'she/her',
  'he/him', 'they/them'. Never guess this; leave it blank if not explicitly provided.
  """
  pronouns: String
  dateOfBirth: Date
  displayName: String @deprecated(reason: "Please use fullName instead of this field.")

  """We recommend you use preferredName or fullName instead of this field."""
  firstName: String @deprecated(reason: "Use 'givenName' instead")

  """We recommend you use preferredName or fullName instead of this field."""
  lastName: String @deprecated(reason: "Use 'familyName' instead")
  fullName: String
  preferredName: String
  portfolioId: ID
  specialCircumstances: SpecialCircumstancesType
  preferences: AccountUserCommsPreferences
  landlinePhoneNumber: String @deprecated(reason: "Use 'landline' instead.")
  alternativePhoneNumbers: [String]
  hasFamilyIssues: Boolean

  """List of hold music options."""
  holdMusicChoices: [TrackOptionType]
}

"""An object holding a subset of account."""
type AccountWithStatusInfoType {
  number: String!

  """The current status of the account."""
  status: AccountStatus

  """The current balance of the account."""
  balance: Int

  """The active payment method for the account."""
  activePaymentMethod: String
}

type ActiveAppointmentType {
  id: UUID!
  agent: SiteworksAppointmentAgent

  """The current status of the Siteworks application."""
  status: SiteworksAppointmentStatus
  appointmentDate: Date!
  createdAt: DateTime!
  date: Date
  requestId: String
  agentReference: String
}

"""Add credit to a smart prepayment meter."""
type AddCreditToSmartMeter {
  """Top-up amount in pence to add to smart meter"""
  amount: Int!
}

type AddressAPIElectricityMeterPointType {
  mpan: String
  profileClass: String
}

type AddressAPIGasMeterPointType {
  mprn: String
}

"""


This field is a connection type. Connections are used to implement [cursor based
pagination](https://graphql.org/learn/pagination/#pagination-and-edges).


"""
type AddressConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AddressConnectionTypeEdge]!
}

"""A Relay edge containing a `AddressConnectionType` and its cursor."""
type AddressConnectionTypeEdge {
  """The item at the end of the edge"""
  node: AddressType

  """A cursor for use in pagination"""
  cursor: String!
}

input AddressInput {
  addressLine1: String
  addressLine2: String
  addressLine3: String
  addressLine4: String
  addressLine5: String

  """Postcode of the property where the appointment took place."""
  postcode: String!
}

input AddressSearchType {
  addressLine1: String!
  addressLine2: String!
  addressLine3: String!
  town: String!
  county: String!
  postcode: String!
}

type AddressType {
  """A unique ID per address using part of the address with spaces removed."""
  addressKey: String!

  """The complete and human-legible address in a single string."""
  display: String!

  """The ID of the Grid Supply Point Group that the address belongs to."""
  gspGroupId: String!

  """
  Line 1 of the address. This is generally the house number and street name. 
  """
  line1: String!

  """Line 2 of the address. This is generally the area or village. """
  line2: String!

  """Line 3 of the address. This is generally the area or village. """
  line3: String!

  """Line 4 of the address. This is generally the city. """
  line4: String!

  """Line 5 of the address. This is generally the county. """
  line5: String!
  postcode: String!

  """
  The identifier for a property. The house number consists of the part of line 1
  of the address that is not the street name. This includes sub-building names,
  building names, deliver point aliases and building numbers.For example, the
  house number for the property 'Flat 12 100 Example St' would be 'Flat 12 100'. 
  """
  houseNumber: String

  """
  The street name for a property. The street name consists of the part of line 1
  of the address that is not the house number.For example, the house number for
  the property 'Flat 12 100 Example St' would be 'Example St'. 
  """
  streetName: String
  hasPrepaidMeters: Boolean!
  gasMeterPoints: [AddressAPIGasMeterPointType]
  electricityMeterPoints: [AddressAPIElectricityMeterPointType]
}

"""Affiliate link for the organization."""
type AffiliateLinkType {
  id: ID!
  organisation: AffiliateOrganisationType
  subdomain: String!
  trainingStatus: LinkTrainingStatus!
  isBusiness: Boolean!
  contactName: String!
  contactEmail: String!
  landingUrl: String!
}

type AffiliateOrganisationType {
  name: String!
  salesChannel: String!
}

"""An enumeration."""
enum AgentContractStatusType {
  """The contracts that have been accepted by the agent."""
  ACCEPTED

  """The contracts that have been rejected by the agent."""
  REJECTED

  """The contracts that have been requested by the supplier."""
  REQUESTED

  """
  The contracts for which termination has been requested by the supplier.
  """
  TERMINATION_REQUESTED

  """The contracts that have been terminated."""
  TERMINATED
}

type Agreement {
  id: ID!
}

interface AgreementInterface {
  id: Int
  validFrom: DateTime
  validTo: DateTime
  agreedFrom: DateTime
  agreedTo: DateTime
  isRevoked: Boolean
}

input AgreementRenewalProductInput {
  """
  The Kraken ID of the agreement to be renewed. The agreement must be currently active.
  """
  agreementId: ID!

  """The code of the product the agreement will be renewed to."""
  productCode: String!
}

"""Amend unbilled electricity reading."""
type AmendUnbilledElectricityReading {
  readingAmended: Boolean
}

input AmendUnbilledReadingInput {
  """The ID of the reading that will be amended."""
  readingId: Int!

  """The new value of reading."""
  readingValue: Int!

  """The new datetime of reading."""
  readingDatetime: DateTime!
}

type AnnualStatementConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AnnualStatementConnectionTypeEdge]!
}

"""
A Relay edge containing a `AnnualStatementConnectionType` and its cursor.
"""
type AnnualStatementConnectionTypeEdge {
  """The item at the end of the edge"""
  node: AnnualStatementType

  """A cursor for use in pagination"""
  cursor: String!
}

"""
Annual statements that are sent to the account. They summarize important information about usage and tariffs.
"""
type AnnualStatementType {
  periodStartsAt: DateTime!
  periodEndsAt: DateTime!
  id: ID
  pdfUrl: String
}

type APIKeyAuthentication {
  token: String
  errors: [ErrorType]
}

"""An enumeration."""
enum AppointmentStatus {
  """The appointment has been booked."""
  BOOKED

  """The appointment was cancelled either by the customer or the agent."""
  CANCELLED

  """
  The appointment was aborted. Choose this option for partially completed work
  (e.g. on a dual fuel meter exchange where one meter was exchanged successfully
  but the other exchange could not be completed.
  """
  ABORTED

  """The appointment has been completed successfully."""
  COMPLETED
}

"""An enumeration."""
enum AppSessionOutcome {
  """Switched"""
  SWITCHED

  """Switched (Credit Check Waiver)"""
  SWITCHED_CREDIT_CHECK_WAIVER

  """Quoted - no switch"""
  QUOTED_NO_SWITCH

  """Quoted - no sale price"""
  QUOTED_NO_SALE_PRICE

  """Quoted - no sale exit fees"""
  QUOTED_NO_SALE_EXIT_FEES

  """Quoted - no sale no email"""
  QUOTED_NO_SALE_NO_EMAIL

  """Quoted - no sale issue bank details"""
  QUOTED_NO_SALE_ISSUE_BANK_DETAILS

  """Quoted - no sale paper bills"""
  QUOTED_NO_SALE_PAPER_BILLS

  """Quoted - no sale monthly dd"""
  QUOTED_NO_SALE_MONTHLY_DD

  """Quoted - no sale credit check issue"""
  QUOTED_NO_SALE_CREDIT_CHECK_ISSUE

  """Quoted - no sale other"""
  QUOTED_NO_SALE_OTHER

  """Pitch - no quote"""
  PITCH_NO_QUOTE

  """No pitch"""
  NO_PITCH

  """No pitch - switched recently"""
  NO_PITCH_SWITCHED_RECENTLY

  """No pitch - vulnerable"""
  NO_PITCH_VULNERABLE

  """No pitch - no d2d"""
  NO_PITCH_NO_D2D

  """No pitch - not interested"""
  NO_PITCH_NOT_INTERESTED

  """Pitch no quote - switched recently"""
  PITCH_NO_QUOTE_SWITCHED_RECENTLY

  """Pitch no quote - price"""
  PITCH_NO_QUOTE_PRICE

  """Pitch no quote - in contract"""
  PITCH_NO_QUOTE_IN_CONTRACT

  """Pitch no quote - no email"""
  PITCH_NO_QUOTE_NO_EMAIL

  """Pitch no quote - not interested"""
  PITCH_NO_QUOTE_NOT_INTERESTED

  """Callback"""
  CALLBACK

  """Quoted - callback"""
  QUOTED_CALLBACK

  """No answer"""
  NO_ANSWER

  """Not bill payer"""
  NOT_BILL_PAYER

  """Busy"""
  BUSY

  """Don’t call again"""
  DONT_CALL_AGAIN

  """No cold calling"""
  NO_COLD_CALLING

  """Sheltered housing"""
  SHELTERED_HOUSING

  """No fixed address"""
  NO_FIXED_ADDRESS

  """Occupy account"""
  OCCUPY_ACCOUNT

  """Occupier - not bill payer"""
  OCCUPIER_NOT_BILL_PAYER

  """Occupier - no answer"""
  OCCUPIER_NO_ANSWER

  """Occupier - refused to discuss"""
  OCCUPIER_REFUSED_TO_DISCUSS

  """Occupier - suspected empty property"""
  OCCUPIER_SUSPECTED_EMPTY_PROPERTY

  """Meter reading"""
  METER_READING

  """Meter reading - unable to take reading"""
  METER_READING_UNABLE_TO_TAKE_READING

  """Meter reading - no answer"""
  METER_READING_NO_ANSWER

  """Wrong address selected"""
  WRONG_ADDRESS_SELECTED

  """Prepayment meter"""
  PREPAYMENT_METER

  """Already an existing customer"""
  EXISTING_CUSTOMER

  """Lead generation"""
  LEAD_GENERATION

  """Electric vehicle lead generation"""
  LEAD_GENERATION_EV
}

input AuthenticationInput {
  """SSO access token for the chosen provider authentication."""
  accessToken: String

  """
  Provider code from user login, exchanged in the backend for SSO credentials.
  """
  authorizationCode: String

  """SSO refresh token for the chosen provider authentication."""
  refreshToken: String

  """
  SSO token expiry for the provider's authentication (integer in seconds).
  """
  expiresIn: Int
}

input BespokeElectricityUnitRatesInput {
  """
  Electricity bespoke unit rate to override the unit rate associated with the tariff.
  """
  unitRate: Decimal!

  """Rate type associated with the given unit rate."""
  rateType: NonBespokeElectricityRateTypeChoices!
}

input BespokeTariffRatesInput {
  """Bespoke standing charge."""
  standingCharge: Decimal

  """Gas bespoke unit rate."""
  unitRate: Decimal

  """Electricity bespoke unit rates with their associated rate type."""
  unitRates: [BespokeElectricityUnitRatesInput]
}

"""


This field is a connection type. Connections are used to implement [cursor based
pagination](https://graphql.org/learn/pagination/#pagination-and-edges).


"""
type BillConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [BillConnectionTypeEdge]!
}

"""A Relay edge containing a `BillConnectionType` and its cursor."""
type BillConnectionTypeEdge {
  """The item at the end of the edge"""
  node: BillInterface

  """A cursor for use in pagination"""
  cursor: String!
}

"""Information about an account's billing schedule."""
type BillingOptionsType {
  """
  The day of the month on which the account's billing period should start.
  """
  periodStartDay: Int
  periodLength: AccountBillingOptionsPeriodLength

  """
  If true, this account is billed on specific day of a regular cycle. If false,
  the billing schedule is flexible, depending on when meter readings are submitted.
  """
  isFixed: Boolean!

  """The date on which the current billing cycle started."""
  currentBillingPeriodStartDate: Date

  """
  The date on which the current billing cycle will end. Null if the account is on flexible billing.
  """
  currentBillingPeriodEndDate: Date

  """
  The next date on which this account will next be billed. This is the same as
  the start date for their next bill cycle. Null if the account is on flexible billing.
  """
  nextBillingDate: Date
}

interface BillInterface {
  id: ID
  billType: BillTypeEnum
  fromDate: Date
  toDate: Date

  """
  Requesting this field generates a temporary URL at which bill is available.
          This URL will expire after approximately an hour.  It is intended for redirection purposes,
          NOT persistence in any form (e.g. inclusion in emails or the body of a web page).
          This field can raise an error with errorClass NOT_FOUND if the bill document has not
          been created/issued yet.
  
  
          Expected `errorClass`:
  - NOT_FOUND
  - SERVICE_AVAILABILITY
  """
  temporaryUrl: String

  """The date the bill was sent to the customer."""
  issuedDate: Date
}

enum BillTypeEnum {
  STATEMENT
  INVOICE
  CREDIT_NOTE
  PRE_KRAKEN
}

"""Allows account users to cancel their own siteworks appointment."""
type CancelSiteworksAppointment {
  siteworksAppointment: ActiveAppointmentType
}

input CancelSiteworksAppointmentInput {
  """The siteworks appointment id to be cancelled."""
  appointmentId: ID!
}

"""An enumeration."""
enum Category {
  FILE_ATTACHMENT_MCS_CERT
  FILE_ATTACHMENT_DNO_LETTER
}

"""A charge to the customer."""
type Charge implements TransactionType {
  id: ID
  postedDate: Date

  """Gross amount including tax whenever tax is payable."""
  amount: Int

  """
  The customer's resulting balance in pence after this transaction has been applied.
  """
  balanceCarriedForward: Int

  """Deprecated"""
  isCredit: Boolean

  """Deprecated"""
  isAccountCharge: Boolean

  """Deprecated"""
  isAccountPayment: Boolean

  """
  Whether the statement this transaction is on has been held. A held statement
  is not sent to a customer automatically, but is instead marked for manual
  attention by operations staff.
  """
  isHeld: Boolean
  title: String
  statementId: ID
  isReversed: Boolean!

  """
  If this charge is for consumption of a good or service, this field will
  contain details of how much was consumed. Omitted in cases where the charge is
  not for consumption, or where consumption information is not available (e.g.
  for some older records).
  """
  consumption: Consumption
}

type ChargeCardType {
  id: ID!
  uid: String!
  nameOnCard: String!
}

type ChargePointDevicesType {
  make: String
  models: [ChargePointModelsType]
}

input ChargePointInput {
  """The charge point make."""
  make: String!

  """The charge point model."""
  model: String!

  """The charge point power (kW)."""
  power: Decimal!
}

type ChargePointModelsType {
  model: String
  powerInKw: [String]
}

"""

    How the CHF was installed and connected to the rest of the Smart Metering System.
    
"""
enum CHFConnectionMethod {
  """Hot Shoe."""
  HOT_SHOE

  """Cradle."""
  CRADLE

  """Esme."""
  ESME
}

"""

    The user's description of the fault, if the meter was not installed due to a technical problem.
    
"""
enum CHFFaultReason {
  """Damaged Case."""
  DAMAGED_CASE

  """Damaged connector."""
  DAMAGED_CONNECTOR

  """Illegal Interference Or Missing Seals."""
  ILLEGAL_INTERFERENCE_OR_MISSING_SEALS

  """Environmental Conditions Exceeded."""
  ENVIRONMENTAL_CONDITIONS_EXCEEDED

  """Fault with SM WAN."""
  SM_WAN_FAULT

  """Fault with SM HAN interface."""
  SM_HAN_FAULT

  """Fault with LED."""
  LED_FAULT

  """Fault with aerial."""
  AERIAL_FAULT

  """Manufacturing Defect."""
  MANUFACTURING_DEFECT
}

"""

    Whether the fault was identified before or after the installation.
    
"""
enum CHFFaultReturnType {
  """Prior To Installation."""
  PRIOR_TO_INSTALLATION

  """Post Installation."""
  POST_INSTALLATION
}

"""

    Whether it is a new or replacement CHF.
    
"""
enum CHFInstallType {
  """New."""
  NEW

  """Replacement."""
  REPLACEMENT
}

"""

    Location of the CHF.
    
"""
enum CHFLocation {
  """Outside of the premises."""
  OUTSIDE

  """Indoors On External Wall."""
  INDOORS_ON_EXTERNAL_WALL

  """Indoors, NOT on an external wall."""
  DEEP_INDOORS

  """In the basement/cellar."""
  BASEMENT_OR_CELLAR
}

"""

    The reason for the meter not being installed if there was no technical issue.
    
"""
enum CHFNoFaultReturnType {
  """General."""
  GENERAL

  """Non-domestic opt-out."""
  NON_DOMESTIC_OPT_OUT

  """Dual supplier HAN variant replacement."""
  DUAL_SUPPLIER_HAN_VARIANT_REPLACEMENT

  """SM WAN variant replacement requested by DCC."""
  SM_WAN_VARIANT_REPLACEMENT

  """Lost or stolen hub."""
  LOST_OR_STOLEN_HUB
}

input ClimateControlStateInput {
  """Account number."""
  accountNumber: String!

  """
  The state that the climate control device should be set to. A value of true
  indicates that the device should be turned on, and a value of false indicates
  it should be switched off. 
  """
  state: Boolean!
}

"""Collect deposit for the given account."""
type CollectDeposit {
  payment: CollectDepositOutput
}

input CollectDepositInput {
  accountNumber: String!
  depositKey: String!
  idempotencyKey: String!
}

type CollectDepositOutput {
  status: CollectDepositStatusChoices
  paymentDate: Date
}

enum CollectDepositStatusChoices {
  APPROVED
  CLEARED
  CANCELLED
  HELD_FOR_REVIEW
  FAILED
  PENDING
  REQUESTED
  SCHEDULED
  NONE
}

input CommissionInput {
  """The third-party intermediary who sold this renewal to the customer."""
  organizationName: String!

  """
  The amount to add to the unit rate when billing, in pence/kWh, which is paid to the third-party intermediary.
  """
  unitRateUplift: Decimal!
}

type CommissionMeter {
  """The id of the SMETS Commission Request in Kraken."""
  requestReference: String
}

input CommissionMeterInput {
  mpxn: String

  """Device ID of the CHF (Communications Hub Function)."""
  chfDeviceId: String!

  """Device ID (ESME or GSME) of the device being commissioned."""
  meterDeviceId: String!

  """
  Code provided by manufacturer as part of ASN data, and included as part of
  device pre-notification, which is required to authorise device commissioning.
  """
  installationCode: String!

  """Type of meter being commissioned"""
  meterType: MeterTypeChoices!
}

"""The method the account has specified they prefer we contact them"""
enum CommsDeliveryPreference {
  EMAIL
  POSTAL_MAIL
}

"""

    The type of comms hub status update request to be sent.
    
"""
enum CommsHubStatusUpdateType {
  """Success."""
  SUCCESS

  """No SM Wide Area Network."""
  NO_SM_WAN

  """Returning CHF due to technical fault."""
  FAULT_RETURN

  """Returning CHF for non-technical reason."""
  NO_FAULT_RETURN
}

type ConfirmSiteworksAppointmentSlot {
  siteworksAppointment: ActiveAppointmentType
}

input ConfirmSiteworksAppointmentSlotInput {
  propertyId: ID!
  appointmentDate: Date!
  startTime: Time!
  endTime: Time!
  additionalInformation: String
}

type Consumption {
  startDate: Date
  endDate: Date
  quantity: Decimal
  unit: ConsumptionUnit
  usageCost: Int
  supplyCharge: Int
}

"""Pagination for energy consumption readings."""
type ConsumptionConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ConsumptionEdge]!
}

type ConsumptionDistributionCoefficients {
  day: Decimal!
  night: Decimal!
}

"""A Relay edge containing a `Consumption` and its cursor."""
type ConsumptionEdge {
  """The item at the end of the edge"""
  node: ConsumptionType

  """A cursor for use in pagination"""
  cursor: String!
}

type ConsumptionEstimate {
  elecAnnualConsumptionStandard: Int
  elecAnnualConsumptionDay: Int
  elecAnnualConsumptionNight: Int
  gasAnnualConsumption: Int
}

type ConsumptionEstimates {
  low: ConsumptionEstimate
  medium: ConsumptionEstimate
  high: ConsumptionEstimate
}

"""An enumeration."""
enum ConsumptionGroupings {
  HALF_HOUR
  HOUR
  DAY
  WEEK
  MONTH
  QUARTER
}

"""Energy consumption between two points in time."""
type ConsumptionType {
  value: Decimal
  startAt: DateTime
  endAt: DateTime
}

"""An enumeration."""
enum ConsumptionUnit {
  kWh
  MJ
}

type CoordinatesType {
  latitude: Float
  longitude: Float
}

"""Add charges to an account."""
type CreateAccountCharge {
  accountCharge: AccountChargeType
}

"""The input type for the account charge."""
input CreateAccountChargeInput {
  """The account number."""
  accountNumber: String!

  """The net amount of the charge to be added."""
  netAmount: Int!

  """The gross amount of the charge to be added."""
  grossAmount: Int!

  """The sales tax amount of the charge to be added."""
  salesTaxAmount: Int!

  """The climate change levy amount of the charge to be added."""
  cclAmount: Int

  """Any extra data that will be associated with account charge."""
  metadata: JSONString

  """Optional short note about account charge."""
  note: String

  """The reason why the charge is added to the account."""
  reason: AccountChargeReasonType!
}

"""Add credits to an account."""
type CreateAccountCredit {
  accountCredit: AccountCreditType
}

"""The input type for the account credit."""
input CreateAccountCreditInput {
  """The account number."""
  accountNumber: String!

  """The net amount of the credit to be created."""
  netAmount: Int!

  """The gross amount of the credit to be created."""
  grossAmount: Int!

  """The sales tax amount of the credit to be created."""
  salesTaxAmount: Int!

  """Any extra data that will be associated with account credit."""
  metadata: JSONString

  """Optional short note about account credit."""
  note: String

  """The reason why the credit is added to the account."""
  reason: AccountCreditReasonType!
}

input CreateAccountFileAttachmentInput {
  filename: String!
  accountNumber: String!
  category: Category!
  clientMutationId: String
}

type CreateAccountFileAttachmentPayload {
  postRequest: UploadPostRequest
  clientMutationId: String
}

"""Create an account reference."""
type CreateAccountReference {
  accountReference: AccountReferenceType
}

"""Create an affiliate link for a new sales agent."""
type CreateAffiliateLink {
  affiliateLink: AffiliateLinkType
}

input CreateAffiliateLinkInputType {
  """The organisation for whom to create the affiliate link for."""
  organisationId: ID!

  """
  
  Will be validated as follows:
  
  - should be at least two characters
  - should only contain (letters, numbers, and Hyphen)
  - should not contain bad words
  - should not contain any of the reserved words including:
   kraken, www, tech, mail, click, business, webhooks, api, www2, sendgrid, friends, developer, consul, affiliates
  """
  subdomain: String!
  contactName: String!
  contactEmail: String!
}

"""Create a new deposit agreement for the account if it needs one."""
type CreateDepositAgreement {
  depositAgreement: CreateDepositAgreementOutput
}

input CreateDepositAgreementInput {
  accountNumber: String!
  depositKey: String!
  reason: String!
}

type CreateDepositAgreementOutput {
  depositRequired: Boolean
  depositAmount: Int
}

"""
Receives the device schedule, validates it, then spins off a task that instructs
the device to follow it. Responds to the consumer with a Kraken ID for the schedule.
"""
type CreateDeviceSchedule {
  schedule: DeviceSchedule
}

type CreateDirectDebitInstruction {
  directDebitInstruction: DirectDebitInstructionType
}

input CreateDirectDebitInstructionInput {
  accountNumber: String!
  directDebitInstruction: DirectDebitInstructionLocalBankDetailsInput!
}

"""Create an Electric Juice agreement for an account."""
type CreateElectricJuiceAgreement {
  agreement: Agreement
}

"""The input type for creating an Electric Juice agreement."""
input CreateElectricJuiceAgreementInput {
  """The account number."""
  accountNumber: String!

  """The time from which the new agreement is valid (default: now)."""
  validFrom: DateTime
}

"""Create an Electric Juice charge and associated line items."""
type CreateElectricJuiceCharge {
  accountCharge: AccountChargeType
}

"""Create a new Electric Juice charge card for an account."""
type CreateElectricJuiceChargeCard {
  chargeCard: ChargeCardType
}

"""The input type for creating a new Electric Juice charge card."""
input CreateElectricJuiceChargeCardInput {
  """The UID on the charge card."""
  chargeCardUid: String!

  """The name printed on the charge card."""
  nameOnCard: String!

  """
  The account number of the account this charge card should be associated with.
  """
  accountNumber: String!
}

"""The input type for adding a charge for Electric Juice."""
input CreateElectricJuiceChargeInput {
  """The account number."""
  accountNumber: String!

  """
  The UID of the Electric Juice charge card to associate with this charge.
  """
  chargeCardUid: String

  """The start time of the charge period."""
  periodStartAt: DateTime!

  """The end time of the charge period."""
  periodEndAt: DateTime!

  """The amount to be charged in units of CURRENCY (excl. tax)."""
  netAmount: Int!

  """The currency of the charge."""
  currency: CurrencyOptions!

  """The provider that originated this charge."""
  chargeProvider: String!

  """The location of the charging point this charge is associated with."""
  postcode: String!

  """The amount of energy consumed in kWh."""
  kwhUsed: Decimal!

  """The price per kWh in units of CURRRENCY."""
  pricePerKwh: Decimal!

  """
  The price of additional (non-consumption) fees on this charge in units of CURRRENCY.
  """
  additionalFees: Int!
}

"""Add a credit to an Electric Juice Network ledger."""
type CreateElectricJuiceCredit {
  accountCredit: AccountCreditType
}

"""The input type for an Electric Juice ledger credit."""
input CreateElectricJuiceCreditInput {
  """The account number."""
  accountNumber: String!

  """The net amount of the credit to be created."""
  netAmount: Int!

  """The gross amount of the credit to be created."""
  grossAmount: Int!

  """The tax amount of the credit to be created."""
  taxAmount: Int!

  """Optional short note about account credit."""
  note: String

  """The reason why the credit is added to the account."""
  reason: AccountCreditReasonType!
}

"""Create metadata on an object."""
type CreateMetadata {
  metadata: Metadata
}

type CreateMeterReadingOutputType {
  readingErrors: [SerializerFieldErrorsType]
  id: String @deprecated(reason: "The `ID` field is depreciated.")
}

"""Create a new job or update the status of an existing one."""
type CreateOrUpdateSiteworksAppointment {
  result: CreateOrUpdateSiteworksAppointmentOutput
}

input CreateOrUpdateSiteworksAppointmentInput {
  """
  The market ID of the agent that carried out the work. This should be an
  electricity market participant ID or gas market code.
  """
  agentId: String!

  """The unique appointment reference of the agent."""
  appointmentReference: String!

  """
  The scheduled date of the appointment. Required if the appointment is not already booked.
  """
  appointmentDate: Date!

  """The status of the appointment."""
  status: AppointmentStatus!

  """The type of work the appointment has been booked for."""
  workType: String

  """The categories of meter the work applies to."""
  fuelType: FuelType!

  """Required if `fuel_type` is `ELECTRICITY` or `DUAL_FUEL`."""
  mpan: String

  """Required if `fuel_type` is `GAS` or `DUAL_FUEL`."""
  mprn: String
  electricitySupplyType: ElectricitySupplyType
  gasSupplyType: GasSupplyType

  """
  The start time of the slot during which the engineer is scheduled at the property.
  """
  timeSlotStart: Time!

  """
  The end time of the slot during which the engineer is scheduled at the property.
  """
  timeSlotEnd: Time

  """Address of the property where the appointment is taking place."""
  address: AddressInput

  """Boolean flag to indicate an emergency appointment."""
  isEmergency: Boolean

  """Name of engineer currently assigned to the appointment."""
  engineerName: String

  """
  Extra context to a change in status such as abort or cancellation reason.
  """
  statusReason: String

  """Free text comments about the appointment."""
  jobNotes: String

  """If applicable, the category of new meters installed."""
  newMeterCategory: NewMeterCategory

  """A list of electricity meters that the work applies to."""
  electricityMeters: [MeterInput]

  """A list of electricity meters that the work applies to."""
  gasMeters: [MeterInput]
}

type CreateOrUpdateSiteworksAppointmentOutput {
  appointmentCreated: Boolean
  appointmentUpdated: Boolean
}

"""Create a payment intent for paying with external payment providers."""
type CreatePaymentIntent {
  paymentIntent: PaymentIntentType
}

"""The input type for the payment intent."""
input CreatePaymentIntentInput {
  """The account number."""
  accountNumber: String!

  """The amount of the payment intent to be created."""
  amount: Int!
  date: Date!
}

"""
Mutation for creating an Payment Schedule instance using the authenticated user.
"""
type CreatePaymentSchedule {
  paymentSchedule: PaymentScheduleType
}

input CreateQuoteInput {
  postcode: String!
  electricityMeterPoints: [ElectricityMeterPointConsumptionInput]
  gasMeterPoints: [GasMeterPointConsumptionInput]

  """
  Used to verify the position that field sales agents generate quotes from
  """
  position: PositionInput
  gspGroupId: String = ""
  affiliateSessionId: String = ""
  brandCode: String!
}

type CreateQuoteOutputType {
  errors: [SerializerFieldErrorsType]
  quote: QuoteType
}

"""Mutation for creating an refund request for an account."""
type CreateRefundRequest {
  refundRequest: RefundRequestType
}

input CreateShellAccountInput {
  givenName: String!
  familyName: String!
  billingName: String
  email: String!
  mobile: String!
  billingAddressLine1: String!
  billingAddressLine2: String!
  billingAddressLine3: String
  billingAddressLine4: String
  billingAddressLine5: String
  billingPostcode: String!
  isBusinessAccount: Boolean
  password: String
  passwordUpdateToken: String
  urn: String
  clientMutationId: String
}

"""
Create a shell account (a billable account with no property/energy supply).
"""
type CreateShellAccountPayload {
  givenName: String!
  familyName: String!
  billingName: String
  email: String!
  mobile: String!
  billingAddressLine1: String!
  billingAddressLine2: String!
  billingAddressLine3: String
  billingAddressLine4: String
  billingAddressLine5: String
  billingPostcode: String!
  isBusinessAccount: Boolean
  password: String
  passwordUpdateToken: String
  urn: String
  errors: [ErrorType]
  account: AccountInterface
  clientMutationId: String
}

"""
Create a Siteworks event.

Currently, only events for reporting are enabled.
"""
type CreateSiteworksEvent {
  eventCreated: Boolean
}

"""
Makes it possible to create Sitework events by external third parties.

This mutation uses the external JWT authorization method.
"""
type CreateSiteworksEventExternal {
  eventCreated: Boolean
}

input CreateSiteworksEventInput {
  """The Siteworks request id."""
  siteworksRequestId: String!

  """The type of Siteworks event that will be created."""
  eventType: SiteworksEventType!

  """The content that might be submitted as field servies data."""
  fieldServicesData: JSONString

  """The references that are related to jobs, appointments etc."""
  references: JSONString

  """The notes that are associated with the Siteworks event."""
  eventNotes: String
}

"""A credit to the customer from the energy retailer."""
type Credit implements TransactionType {
  id: ID
  postedDate: Date

  """Gross amount including tax whenever tax is payable."""
  amount: Int

  """
  The customer's resulting balance in pence after this transaction has been applied.
  """
  balanceCarriedForward: Int

  """Deprecated"""
  isCredit: Boolean

  """Deprecated"""
  isAccountCharge: Boolean

  """Deprecated"""
  isAccountPayment: Boolean

  """
  Whether the statement this transaction is on has been held. A held statement
  is not sent to a customer automatically, but is instead marked for manual
  attention by operations staff.
  """
  isHeld: Boolean
  title: String
  statementId: ID
  isReversed: Boolean!
}

enum CurrencyOptions {
  UK_PENCE
}

input CustomerFeedbackInputType {
  answer: String
  issueResolved: Boolean!
  formId: Int!
  feedbackId: Int!
  accountNumber: String!
}

type CustomerFeedbackType {
  id: ID!

  """The value attached to the source"""
  rawScore: Int

  """The datetime the feedback was submitted"""
  submittedAt: DateTime
}

"""
The `Date` scalar type represents a Date
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar Date

"""
The `DateTime` scalar type represents a DateTime
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar DateTime

type DayNightTariff implements TariffType {
  id: ID
  displayName: String
  fullName: String
  description: String
  productCode: String
  standingCharge: Float
  preVatStandingCharge: Float
  dayRate: Float
  nightRate: Float
  preVatDayRate: Float
  preVatNightRate: Float
}

"""The `Decimal` scalar type represents a python Decimal."""
scalar Decimal

type DecommissionSmartDevice {
  """The reference of the Decommission Request in Kraken."""
  requestReference: String
}

input DecommissionSmartDeviceInput {
  """Device ID for the device being decommissioned."""
  deviceId: String!
}

"""Payment Instructions"""
type DefaultElectricJuicePaymentInstructionType {
  id: ID!
  instructionType: String
  cardPaymentNetwork: String
  cardExpiryMonth: Int
  cardExpiryYear: Int
  validFrom: DateTime!

  """
  The provider to use for this DDI. Most accounts would have SmartDebit as their provider, Iresa customers use GoCardless
  """
  vendor: String!
  cardNumber: String!
  cardType: String
}

type DeleteBoostCharge {
  krakenflexDevice: KrakenFlexDeviceType
}

input DeleteBoostChargeInput {
  """Account number."""
  accountNumber: String!
}

"""
Delete the connection details for a device registered for a given account number.
"""
type DeleteDeviceConnectionDetails {
  upsideDevice: UpsideDeviceType @deprecated(reason: "upsideDevice is deprecated. Use krakenflexDevice instead.")
  krakenflexDevice: KrakenFlexDeviceType
}

input DepositAgreementInput {
  accountNumber: String!
  depositKey: String!
}

type DepositAgreementOutput {
  depositKey: String
  depositAmount: Int
  acceptedAt: DateTime
  fulfilledAt: DateTime
}

type DeviceSchedule {
  """Primary key of an existing schedule."""
  id: Int
}

input DeviceScheduleEntryInput {
  """
  Charge level of this settlement period. Any values not set to '0' will default to '1'.
  """
  state: Int!

  """
  The start time of the charge settlement period. Must start at the beginning or half of the hour.
  """
  start: Time!

  """
  The end time of the charge period. Must start at the beginning or half of the hour and be later than 'start'.
  """
  end: Time!
}

input DeviceScheduleInput {
  """Alphanumber code identifying the device."""
  deviceId: String!

  """Device state for periods not explicitely specified."""
  defaultState: Int!

  """Arbitrary description for device - e.g. VLCDEV"""
  deviceType: String!

  """Sub identifier for controlling auxiliary units."""
  label: String!

  """The datetime at which the schedule will come into effect."""
  startAt: DateTime!

  """List of settlement periods and their corresponding states."""
  schedule: [DeviceScheduleEntryInput]
}

"""An enumeration."""
enum DeviceStatus {
  """Pending"""
  PENDING

  """Whitelisted"""
  WHITELISTED

  """Installed but not commissioned"""
  INSTALLED_NOT_COMMISSIONED

  """Commissioned"""
  COMMISSIONED

  """Decommissioned"""
  DECOMMISSIONED

  """Withdrawn"""
  WITHDRAWN

  """Suspended"""
  SUSPENDED

  """In recovery"""
  RECOVERY

  """Recovered"""
  RECOVERED

  """Not Applicable"""
  NOT_APPLICABLE
}

"""An enumeration."""
enum DeviceStatuses {
  """Pending"""
  PENDING

  """Device has been whitelisted"""
  WHITELISTED

  """Installed but not commissioned"""
  INSTALLED_NOT_COMMISSIONED

  """Device has been commissioned"""
  COMMISSIONED

  """Device has been decommissioned"""
  DECOMMISSIONED

  """Device has been withdrawn"""
  WITHDRAWN

  """Decice suspended"""
  SUSPENDED

  """Device is in recovery mode"""
  RECOVERY

  """Device recovered"""
  RECOVERED

  """Not applicable"""
  NOT_APPLICABLE
}

"""An enumeration."""
enum DeviceType {
  """Electricity Smart Meter (ESME)"""
  ESME

  """Gas Smart Meter (GSME)"""
  GSME

  """Gas Proxy Function (GPF)"""
  GPF

  """Communications Hub Function (CHF)"""
  CHF

  """HAN Connected Auxiliary Load Control Switch (HCALCS)"""
  HCALCS

  """Prepayment Interface Device (PPMID)"""
  PPMID

  """In-House Display (IHD)"""
  IHD

  """Consumer Access Device (CAD)"""
  CAD

  """IHD or CAD (a type 2 device)"""
  IHD_OR_CAD
}

type DirectDebitInstructionConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [DirectDebitInstructionConnectionTypeEdge]!
}

"""
A Relay edge containing a `DirectDebitInstructionConnectionType` and its cursor.
"""
type DirectDebitInstructionConnectionTypeEdge {
  """The item at the end of the edge"""
  node: DirectDebitInstructionType

  """A cursor for use in pagination"""
  cursor: String!
}

input DirectDebitInstructionLocalBankDetailsInput {
  accountNumber: String!
  accountHolder: String!
  sortCode: String!
}

"""An enumeration."""
enum DirectDebitInstructionStatus {
  """The instruction is active and can be used to take payments."""
  ACTIVE

  """The instruction has not yet been set up."""
  PROVISIONAL

  """The instruction could not be set up with the vendor."""
  FAILED

  """The account for this instruction was closed."""
  ACCOUNT_CLOSED
}

"""Direct Debit Instructions"""
type DirectDebitInstructionType {
  id: ID!
  status: String!
  sortCode: String!
  iban: String!
  accountHolder: String!
  instructionType: String
  cardPaymentNetwork: String
  cardExpiryMonth: Int
  cardExpiryYear: Int

  """The last four digits of the account number."""
  lastFourDigitsOfAccountNumber: String @deprecated(reason: "Use 'masked_account_identifier' for a masked reference to the instruction. This field is misleading, as it's only the last 3 digits that are stored. We'll remove this field on 14/03/2020.")

  """A masked reference to a recurring payment method."""
  maskedAccountIdentifier: String

  """A masked version of the IBAN."""
  maskedIban: String
}

input DirectDebitPaymentAmountInput {
  accountNumber: String!

  """Amount in pence"""
  amount: Int!
}

type DirectDebitPaymentAmountUpdate {
  paymentSchedule: PaymentScheduleType
  errors: [ErrorType]
}

type DirectDebitPaymentDayUpdate {
  paymentSchedule: PaymentScheduleType
  errors: [ErrorType]
}

input DirectDebitPaymentDayUpdateInput {
  accountNumber: String!
  paymentDay: Int!
}

"""
Mutation to disable the token used to call this mutation. Requires a valid token
for authentication to avoid a potential denial-of-service issue. The token used
for authentication will be the token disabled.
"""
type DisableToken {
  message: String
}

"""The status of DNO being notified of this export request."""
enum DNOStatus {
  """Notified"""
  NOTIFIED

  """Not Notified"""
  NOT_NOTIFIED

  """Unknown"""
  UNKNOWN
}

"""An enumeration."""
enum ElectricityAgentContractContractType {
  """DA"""
  DA

  """DC"""
  DC

  """MOP"""
  MOP
}

"""An organization who manages a given meterpoint."""
type ElectricityAgentContractType {
  contractType: ElectricityAgentContractContractType!
  effectiveFrom: Date!
  agentId: String
  contractStatus: AgentContractStatusType
}

type ElectricityAgreementType implements AgreementInterface {
  id: Int
  validFrom: DateTime
  validTo: DateTime
  agreedFrom: DateTime
  agreedTo: DateTime
  account: AccountType!
  meterPoint: ElectricityMeterPointType!
  tariff: ElectricityTariffType
  isRevoked: Boolean

  """A collection of charges and associated consumption data."""
  lineItems(
    startAt: DateTime!

    """
    Aggregate line items according to this grouping. Note that this doesn't
    guarantee that the returned items will cover a particular length of time, as
    it will depend on how the items have been stored, whether the period had
    daylight savings time changes (and therefore potentially 25 hours) etc.
    """
    grouping: LineItemGroupingOptions!
    itemType: LineItemTypeOptions!

    """Timezone used for grouping."""
    timezone: String!
    before: String
    after: String
    first: Int
    last: Int
  ): LineItemConnection
}

union ElectricityConsumption = ElectricityConsumptionStandard | ElectricityConsumptionLabelEco7 | ElectricityConsumptionThreeRate

type ElectricityConsumptionLabelEco7 {
  day: Int
  night: Int
  isEstimate: Boolean
}

type ElectricityConsumptionStandard {
  consumption: Int
  isEstimate: Boolean
}

type ElectricityConsumptionThreeRate {
  day: Int
  night: Int
  offPeak: Int
  isEstimate: Boolean
}

type ElectricityConsumptionType {
  """The estimated Electricity Annual Consumption measured in kWh."""
  eac: Float

  """The date from which the EAC is calculated."""
  eacEffectiveFromDate: Date

  """The current supplier for the meterpoint."""
  supplierName: String

  """The date the meterpoint switched to the current supplier."""
  supplierEffectiveFromDate: Date

  """
  A flag stating if the meterpoint has ever had an erroneous transfer of supplier.
  """
  hasErroneousTransfer: Boolean
}

"""An enumeration."""
enum ElectricityMeterMeterType {
  """Check"""
  CHECK

  """Half Hourly"""
  H

  """Key"""
  K

  """Lag"""
  LAG_

  """Lead"""
  LEAD_

  """Main"""
  MAIN_

  """Non-Half Hourly"""
  N

  """Non-remotely Configurable Automated Meter Reading"""
  NCAMR

  """
  A meter that meets the definition of an ADM but is not compliant with any version of SMETS
  """
  NSS

  """
  Remotely Configurable Automated Meter Reading without remote enable/disable capability
  """
  RCAMR

  """
  Remotely Configurable Automated Meter Reading with remote enable/disable capability
  """
  RCAMY

  """Smartcard Prepayment"""
  S

  """
  A meter that is compliant with the Smart Metering Equipment Technical Specifications 1 (SMETS1)
  """
  S1

  """A single element meter that is compliant with SMETS2"""
  S2A

  """A twin element meter that is compliant with SMETS2"""
  S2B

  """A polyphase meter that is compliant with SMETS2"""
  S2C

  """
  A single element meter with one or more ALCS that is compliant with SMETS2
  """
  S2AD

  """
  A twin element meter with one or more ALCS that is compliant with SMETS2
  """
  S2BD

  """A polyphase meter with one or more ALCS that is compliant with SMETS2"""
  S2CD

  """
  Single element meter with one or more ALCS and Boost Function that is compliant with SMETS2
  """
  S2ADE

  """
  A twin element meter with one or more ALCS and Boost Function that is compliant with SMETS2
  """
  S2BDE

  """
  A polyphase meter with one or more ALCS and Boost Function that is compliant with SMETS2
  """
  S2CDE

  """Special"""
  SPECL

  """Token"""
  T
}

input ElectricityMeterPointConsumptionInput {
  profileClass: Int
  mpan: String
  isEstimate: Boolean!
  annualConsumptionStandard: Int
  annualConsumptionDay: Int
  annualConsumptionNight: Int
}

type ElectricityMeterPointForAddressType {
  addressHasMoreThanOneElectricityMeterPoint: Boolean!

  """
  List of meterpoints associated with the address. Only returned if
  address_has_more_than_one_electricity_meter_point is True. 
  """
  electricityMeterPoints: [String]

  """Line 1 of the address returned from the search"""
  addressLine1: String

  """Line 2 of the address returned from the search"""
  addressLine2: String

  """The postcode of the address returned from the search"""
  postcode: String
}

"""
An electricity meterpoint is a collection of meters. Meters can be changed over
time, so it is convenient to keep an invariant reference. Sometimes there are
multiple active meters on a meterpoint at a time (eg ECO10), but expect that to
be an edge case.
"""
type ElectricityMeterPointType implements MeterPointInterface {
  id: ID!
  supplyEndDate: Date
  mpan: String!

  """Standard settlement configuration"""
  ssc: String!
  energisationStatus: String!
  dccServiceFlag: String!
  juniferMeterPointId: Int
  statusUpdatedAt: DateTime
  oldSupplierId: String
  newSupplierId: String
  smartStartDate: Date
  requiresEnrolment: Boolean!
  targetSsd: Date
  requiresWithdrawal: Boolean!
  hasOpenOpeningReadDispute: Boolean!
  hasOpenClosingReadDispute: Boolean!
  profileClass: Int

  """Line loss factor class"""
  llf: String

  """Meter timeswitch code"""
  mtc: Int
  measurementClass: String!
  lastValidatedReadingDate: Date

  """Smart Metering System Operator"""
  smsOperator: String!
  smsOperatorEffectiveFrom: Date
  ihdStatus: String!
  ihdEffectiveFrom: Date
  dccEffectiveFrom: Date
  meters(id: Int, includeInactive: Boolean): [ElectricityMeterType]
  status: String

  """Details of an ongoing enrolment process."""
  enrolment: EnrolmentType

  """The distribution network the grid supply point falls under"""
  gspGroupId: String

  """A list of agents responsible for management of the meterpoint."""
  agentContracts(
    """Filter the contracts by status."""
    statuses: [AgentContractStatusType]
  ): [ElectricityAgentContractType]

  """
  A list of electricity agreements belonging to an account that is linked to the
  viewer. Filters out expired agreements by default.
  """
  agreements(validAfter: DateTime, includeInactive: Boolean): [ElectricityAgreementType]
  smartTariffOnboarding: SmartTariffOnboardingType

  """A list of unbilled electricity readings for the meterpoint."""
  unbilledReadings: [ElectricityMeterReadingType]
}

"""


This field is a connection type. Connections are used to implement [cursor based
pagination](https://graphql.org/learn/pagination/#pagination-and-edges).


"""
type ElectricityMeterReadingConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ElectricityMeterReadingConnectionTypeEdge]!
}

"""
A Relay edge containing a `ElectricityMeterReadingConnectionType` and its cursor.
"""
type ElectricityMeterReadingConnectionTypeEdge {
  """The item at the end of the edge"""
  node: ElectricityMeterReadingType

  """A cursor for use in pagination"""
  cursor: String!
}

"""
A electricity meter reading. A reading can in fact contain multiple values for
each register (for example for ECO7). They are collected under a common read_at
datetime and have a common fuel type.
"""
type ElectricityMeterReadingType implements MeterReading {
  id: ID!
  readAt: DateTime
  readingSource: String
  registers: [RegisterReading]
  source: String
}

"""Electricity registers measure consumption."""
type ElectricityMeterRegisterType {
  id: ID!
  identifier: String
  digits: Int
  decimalPlaces: Int
  name: String
  expectedReadingRanges: [[Int]]
  timePatternRegime: String
  unitRateType: String
}

"""
An electricity meter is a collection of registers which store readings. Eco7
meters are an example of a meter with multiple registers (for day and night).
"""
type ElectricityMeterType implements Node & Meter {
  id: ID!
  serialNumber: String!
  requiresAccess: Boolean
  isDigital: Boolean
  installationDate: Date
  lastInspectionDate: Date
  createdAt: DateTime!
  updatedAt: DateTime
  activeFrom: Date!
  activeTo: Date
  meterPoint: ElectricityMeterPointType!
  location: String
  currentRating: Int
  makeAndType: String
  meterType: ElectricityMeterMeterType
  certificationDate: Date
  certifiedUntil: Date
  retrievalMethod: String
  importMeter: ElectricityMeterType
  exportMeters(offset: Int, before: String, after: String, first: Int, last: Int): ElectricityMeterTypeConnection!
  smartImportElectricityMeter: SmartMeterDeviceType
  smartExportElectricityMeter: SmartMeterDeviceType

  """The units of consumption for a smart meter."""
  consumptionUnits: String

  """Whether this meter requires a final change of tenancy (COT) reading."""
  requiresCotFinalReading: Boolean

  """Energy consumption recorded by the meter."""
  consumption(
    """Earliest consumption reading to return. Must specify a timezone."""
    startAt: DateTime!

    """Aggregate consumption according to this grouping."""
    grouping: ConsumptionGroupings!

    """Timezone to use for grouping."""
    timezone: String!
    before: String
    after: String
    first: Int
    last: Int
  ): ConsumptionConnection

  """
  This lets us get around the fact that we already use the field id as a primary
  key. We will migrate the id field over to be this id eventually.
  """
  nodeId: ID!
  readings(before: String, after: String, first: Int, last: Int): ElectricityMeterReadingConnectionTypeConnection
  registers: [ElectricityMeterRegisterType]

  """Returns if the meter has and allows half hourly readings"""
  hasAndAllowsHhReadings: Boolean
  smartDevices: [SmartMeterDeviceType]
}

type ElectricityMeterTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ElectricityMeterTypeEdge]!
}

"""A Relay edge containing a `ElectricityMeterType` and its cursor."""
type ElectricityMeterTypeEdge {
  """The item at the end of the edge"""
  node: ElectricityMeterType

  """A cursor for use in pagination"""
  cursor: String!
}

"""An enumeration."""
enum ElectricityMeterTypes {
  """Key."""
  K

  """Smartcard."""
  S

  """Token."""
  T
}

union ElectricityProductTariffInformationLabel = ProductTariffInformationLabelStandard | ProductTariffInformationLabelEco7 | ProductTariffInformationThreeRate

type ElectricityQuotedProduct {
  label: String!

  """Energy product quoted."""
  product: EnergyProductType!

  """
  Estimated cost in pence of the product over a year based on the quoted usage. 
  """
  annualAmount: Int!

  """
  Estimated cost in pence of the product per month based on the quoted usage.
  """
  monthlyAmount: Int!

  """
  Electricity tariff information label (TIL) provides standardised information
  between suppliers about a tariff.  The type of
  ElectricityProductTariffInformationLabel depends on the rateType of the
  ElectricitySupplyPoint.
  """
  electricityTariffInformationLabel: ElectricityProductTariffInformationLabel!
}

type ElectricitySupplyPoint {
  """The Mpan of the suply point."""
  mpan: String

  """Current active agreement on this supply point."""
  agreement: ElectricityAgreementType

  """
  Annual consumption of the supply point. The type of ElectricityConsumption depends on the rateType.
  """
  annualConsumption: ElectricityConsumption!

  """A list of quoted products and the corresponding tariff information."""
  quotedProducts: [ElectricityQuotedProduct]!

  """Rate type."""
  rateType: RateTypeChoices!
}

"""An enumeration."""
enum ElectricitySupplyType {
  """Single phase meter point."""
  SINGLE_PHASE

  """Three phase meter point."""
  THREE_PHASE
}

union ElectricityTariffType = StandardTariff | DayNightTariff | ThreeRateTariff | HalfHourlyTariff | PrepayTariff

type ElectricVehicleModelType {
  vehicleId: Int
  model: String
  year: Int
  batterySize: Decimal
  supportedProviders: [String]
}

type ElectricVehicleType {
  make: String
  models: [ElectricVehicleModelType]
}

type EmailAttachmentType {
  id: ID!
  filename: String!

  """
  Temporary URL at which the email attachment is available. This URL will expire
  after approximately an hour. It is intended for redirection purposes, NOT
  persistence in any form (e.g. inclusion in emails or the body of a web page).
  """
  temporaryUrl: String
}

type EmailAuthentication {
  token: String
  errors: [ErrorType]
}

type EmailEventType implements Node {
  """The ID of the object."""
  id: ID!
  eventType: String!
  occurredAt: DateTime!

  """
  Email message of the email event. Returns null for message's sent/received by other user's on the account
  """
  message: EmailType
}

"""An enumeration."""
enum EmailFormats {
  """Plain text emails."""
  TEXT

  """Full featured HTML emails with images and branding."""
  HTML
}

type EmailType {
  id: ID!
  sentAt: DateTime

  """Subject line of the email message."""
  subject: String

  """Attachments of the email message."""
  attachments: [EmailAttachmentType]
  textBody: String
  htmlBody: String

  """Email sender"""
  sender: String

  """Email recipient"""
  recipient: String
}

"""An enumeration."""
enum EnergyProductAvailability {
  """Energy products that have not expired as of now."""
  AVAILABLE

  """Energy products that have expired as of now."""
  UNAVAILABLE
}

"""


This field is a connection type. Connections are used to implement [cursor based
pagination](https://graphql.org/learn/pagination/#pagination-and-edges).


"""
type EnergyProductConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [EnergyProductConnectionTypeEdge]!
}

"""
A Relay edge containing a `EnergyProductConnectionType` and its cursor.
"""
type EnergyProductConnectionTypeEdge {
  """The item at the end of the edge"""
  node: EnergyProductType

  """A cursor for use in pagination"""
  cursor: String!
}

"""An enumeration."""
enum EnergyProductFilters {
  """Display our prepayment products."""
  PREPAY

  """Display our business products."""
  BUSINESS

  """Display our domestic products."""
  DOMESTIC

  """Display our variable-term products."""
  VARIABLE

  """Display our fixed-term products."""
  FIXED

  """Display our smart (charged half-hourly) products."""
  SMART

  """Display our greenest products."""
  GREEN
}

"""
An EnergyProduct models a group of tariffs for both electricity and gas.
"""
type EnergyProductType {
  id: ID!
  fullName: String!

  """This name will be shown to customers during sign-up"""
  displayName: String!

  """This will be shown to customers during sign-up"""
  description: String!
  availableFrom: DateTime!
  availableTo: DateTime

  """Whether to hide this product from the direct registration journey"""
  isHidden: Boolean!
  code: String!

  """These are internal notes to explain why this product exists"""
  notes: String!
  isVariable: Boolean!
  isGreen: Boolean!
  isBusiness: Boolean!
  isChargedHalfHourly: Boolean!
  isPrepay: Boolean!

  """A list of tariffs per product for a given postcode"""
  tariffs(postcode: String!, before: String, after: String, first: Int, last: Int): EnergyTariffConnectionTypeConnection
  isAvailable: Boolean
  isUnavailable: Boolean
  isFixed: Boolean
  isDomestic: Boolean
}

"""


This field is a connection type. Connections are used to implement [cursor based
pagination](https://graphql.org/learn/pagination/#pagination-and-edges).


"""
type EnergyTariffConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [EnergyTariffConnectionTypeEdge]!
}

"""A Relay edge containing a `EnergyTariffConnectionType` and its cursor."""
type EnergyTariffConnectionTypeEdge {
  """The item at the end of the edge"""
  node: EnergyTariffType

  """A cursor for use in pagination"""
  cursor: String!
}

union EnergyTariffType = StandardTariff | DayNightTariff | GasTariffType

"""An enumeration."""
enum EnrolmentStatusOptions {
  """
  The previous supplier objects to the switch. The have not has cancelled the
  switch yet, but in 99% cases, they will cancel the switch.
  """
  OBJECTION_RECEIVED

  """
  The previous supplier cancelled the switch. This is a terminal state, and we
  will have to reapply before this can start again.
  """
  REGISTRATION_OBJECTED

  """The overseeing industry body has objected to the switch"""
  REJECTED

  """The request to bring the meter point on supply has been withdrawn."""
  WITHDRAWN

  """
  The meterpoint has been created but the enrolment process has not started yet.
  """
  PRE_REGISTRATION

  """
  Enrolment has been requested. This is the default catch-all status, which is
  returned when no other defined process is happening.
  """
  REQUESTED

  """Enrolment has been completed."""
  COMPLETED

  """
  Enrolment has been disputed. This could be that the meter point details that have been provided have been disputed.
  """
  DISPUTED

  """
  Enrolment has been accepted by the industry, which means that it has all the
  information needed to switch supplier and if that information is correct (to
  it's knowledge)
  """
  ACCEPTED
}

"""Details of an ongoing enrolment process."""
type EnrolmentType {
  """Date the switch started."""
  switchStartDate: Date

  """Target date for supply to start."""
  supplyStartDate: Date

  """The last company to supply this meter point."""
  previousSupplier: String

  """The enrolment status on a meter point."""
  status: EnrolmentStatusOptions
}

type ErrorType {
  field: String!
  messages: [String!]!
}

union ErrorTypeUnion = SerializerErrorType | SerializerFieldErrorsType

"""An enumeration."""
enum ExpiringTokenScope {
  """Scope that enables account user to submit meter readings."""
  SUBMIT_METER_READINGS

  """Scope that enables account user to submit customer feedback."""
  SUBMIT_CUSTOMER_FEEDBACK

  """Scope that enables account user to book smart meter appointments."""
  BOOK_SMART_METER_APPOINTMENTS
}

"""The type of generator technology used for export."""
enum ExportTechnologyType {
  """Hydro"""
  HYDRO

  """Photovoltaic"""
  SOLAR

  """Storage"""
  STORAGE

  """Wind"""
  WIND

  """Photovoltaic and Storage"""
  SOLAR_AND_STORAGE

  """Wind and Storage"""
  WIND_AND_STORAGE
}

type FieldSalesVisitConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [FieldSalesVisitConnectionTypeEdge]!
}

"""
A Relay edge containing a `FieldSalesVisitConnectionType` and its cursor.
"""
type FieldSalesVisitConnectionTypeEdge {
  """The item at the end of the edge"""
  node: FieldSalesVisitType

  """A cursor for use in pagination"""
  cursor: String!
}

"""A field sales visit at an address."""
type FieldSalesVisitType {
  startedAt: DateTime!
  stoppedAt: DateTime!
  addressLine1: String!
  addressLine2: String!
  addressLine3: String!

  """Post town"""
  addressLine4: String!

  """County"""
  addressLine5: String!
  outcome: AppSessionOutcome
  affiliateLink: AffiliateLinkType
}

interface FileAttachment {
  """Is the file uploaded to S3?"""
  isUploaded: Boolean

  """Is the file ready for use / downloadable?"""
  isReady: Boolean
  fetchUrl: String
  sizeInBytes: Int
}

type FitCreateMeterReadings {
  readingsSubmitted: Boolean
}

input FitInstallationInput {
  fitId: String!
  meters: [FitMeterInput]!
}

input FitMeterInput {
  id: Int!
  reading: FitReadingInput!
}

input FitMeterReadingInput {
  installations: [FitInstallationInput]!
}

type FitMeterType {
  """Serial number of the meter."""
  serialNumber: String

  """ID of the meter."""
  id: String

  """The type of meter."""
  type: String
  readings(before: String, after: String, first: Int, last: Int): FitReadingConnectionTypeConnection

  """Any installation capacities linked to the meter."""
  installationCapacities: [InstallationCapacityType]

  """
  The maximum read volume expected for the current datetime, including any extra tolerance allowed.
  """
  maxExpectedRead: Decimal

  """MPAN of the meter point linked to the meter."""
  mpan: String
}

type FitReadingConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [FitReadingConnectionTypeEdge]!
}

"""A Relay edge containing a `FitReadingConnectionType` and its cursor."""
type FitReadingConnectionTypeEdge {
  """The item at the end of the edge"""
  node: FitReadingType

  """A cursor for use in pagination"""
  cursor: String!
}

input FitReadingInput {
  value: Decimal!
  readAt: DateTime!
}

type FitReadingType {
  value: Decimal!
  readAt: DateTime!
}

"""The ownership status of FiT for this property."""
enum FITStatus {
  """Notified"""
  OWNER

  """Previous owner"""
  PREVIOUS_OWNER

  """Third party owned"""
  THIRD_PARTY_OWNED

  """Unknown"""
  UNKNOWN

  """None"""
  NONE
}

type FollowOnProductType {
  activeFrom: DateTime!
  activeTo: DateTime

  """The type of account."""
  accountType: AccountTypeChoices

  """The payment method for the product."""
  paymentMethod: PaymentMethodChoices
  renewalProducts: [RenewalProductType]
  createdAt: DateTime!
}

input FormSubmissionInput {
  accountNumber: String!

  """Form type"""
  formType: FormType

  """Form content"""
  content: JSONString!
}

type FormSubmissionOuput {
  id: Int
  content: JSONString
  errors: [SerializerFieldErrorsType]
}

"""An enumeration."""
enum FormType {
  """Covid-19 Financial Energy Assessment"""
  COVID_19_FINANCIAL_ENERGY_ASSESSMENT

  """Covid-19 Gas Prices Financial Energy Assessment"""
  COVID_19_GAS_PRICES_FINANCIAL_ENERGY_ASSESSMENT
}

"""An enumeration."""
enum FuelType {
  """Electricity."""
  ELECTRICITY

  """Gas."""
  GAS

  """Dual Fuel."""
  DUAL_FUEL
}

"""An enumeration."""
enum FuelTypeChoices {
  """Electricity."""
  ELECTRICITY

  """Gas."""
  GAS

  """Dual Fuel."""
  DUAL_FUEL
}

"""An enumeration."""
enum GasAgentContactContractType {
  """Meter Asset Manager"""
  MAM

  """Meter Reader Agent"""
  MRA
}

"""An organization who manages a given meterpoint."""
type GasAgentContractType {
  contractType: GasAgentContactContractType!
  agentId: String
  contractStatus: AgentContractStatusType
  effectiveFrom: Date
}

type GasAgreementType implements AgreementInterface {
  id: Int
  validFrom: DateTime
  validTo: DateTime
  agreedFrom: DateTime
  agreedTo: DateTime
  account: AccountType!
  meterPoint: GasMeterPointType!
  tariff: GasTariffType
  isRevoked: Boolean

  """A collection of charges and associated consumption data."""
  lineItems(
    startAt: DateTime!

    """
    Aggregate line items according to this grouping. Note that this doesn't
    guarantee that the returned items will cover a particular length of time, as
    it will depend on how the items have been stored, whether the period had
    daylight savings time changes (and therefore potentially 25 hours) etc.
    """
    grouping: LineItemGroupingOptions!
    itemType: LineItemTypeOptions!

    """Timezone used for grouping."""
    timezone: String!
    before: String
    after: String
    first: Int
    last: Int
  ): LineItemConnection
}

type GasConsumption {
  consumption: Int
  isEstimate: Boolean
}

type GasConsumptionType {
  """The estimated Annual Quantity measured in kWh."""
  aq: Int

  """The current supplier for the meterpoint."""
  supplierName: String

  """The date the meterpoint switched to the current supplier."""
  supplierEffectiveFromDate: Date
}

"""An enumeration."""
enum GasMeterMechanism {
  """Credit"""
  CR

  """Electronic Token Meter"""
  ET

  """Prepayment"""
  PP

  """Mechanical Token Meter"""
  MT

  """Coin Meter"""
  CM

  """Thrift"""
  TH

  """Non Compliant SMETS Smart Meter"""
  NS

  """SMETS 1 compliant Smart Meter"""
  S1

  """SMETS 2 compliant Smart Meter"""
  S2

  """Unknown"""
  U
}

input GasMeterPointConsumptionInput {
  mprn: String
  isEstimate: Boolean!
  annualConsumption: Int
}

"""An enumeration."""
enum GasMeterPointMarketCategory {
  """SSP"""
  SSP

  """LSP"""
  LSP
}

"""An enumeration."""
enum GasMeterPointMarketSectorCode {
  """Domestic"""
  D

  """Industrial"""
  I
}

"""An enumeration."""
enum GasMeterPointMeterOwnershipType {
  """Transporter"""
  T

  """Supplier"""
  S

  """Customer"""
  C
}

"""
A gas meterpoint is a collection of meters. Meters are changed over time, so it
is convenient to keep an invariant reference. We would not expect there to be
multiple active meters at a time on a gas meterpoint.
"""
type GasMeterPointType implements MeterPointInterface {
  id: ID!
  supplyEndDate: Date
  mprn: String
  statusUpdatedAt: DateTime
  oldSupplierId: String
  newSupplierId: String
  smartStartDate: Date
  requiresEnrolment: Boolean!
  targetSsd: Date
  requiresWithdrawal: Boolean!
  hasOpenOpeningReadDispute: Boolean!
  hasOpenClosingReadDispute: Boolean!
  marketSectorCode: GasMeterPointMarketSectorCode
  marketCategory: GasMeterPointMarketCategory
  meterOwnershipType: GasMeterPointMeterOwnershipType
  confirmationReference: Int
  nominationType: String!
  supplyClass: Int!
  nominationShipperReference: String!

  """Industry status code"""
  xoserveStatus: String
  exitCapacityChargeRate: Decimal
  ldzCapacityChargeRate: Decimal
  ldzCommodityChargeRate: Decimal
  ldzCustomerChargeRate: Decimal
  ntsExitCommodityChargeRate: Decimal
  mrfType: String!
  meterReadBatchFrequency: String!

  """SOQ fixed for year"""
  formulaYearSmpSoq: Int

  """AQ fixed for year"""
  formulaYearSmpAq: Int

  """Rolling SOQ"""
  currentDmSoq: Int

  """Rolling SOQ"""
  currentNdmSoq: Int
  exitZone: String!

  """Local distribution zone - Distribution charges are based upon this"""
  ldz: String!
  supplyPointCategory: String!
  endUserCategory: Int
  eucIdentifier: String
  igtIdentifier: String!
  igtCheckedAt: DateTime
  meters(id: Int, includeInactive: Boolean): [GasMeterType]
  status: String

  """Details of an ongoing enrolment process."""
  enrolment: EnrolmentType

  """A list of agents responsible for management of the meterpoint."""
  agentContracts(
    """Filter the contracts by status."""
    statuses: [AgentContractStatusType]
  ): [GasAgentContractType]

  """
  A list of gas agreements belonging to an account that is linked to the viewer. Filters out expired agreements by default.
  """
  agreements(validAfter: DateTime, includeInactive: Boolean): [GasAgreementType]

  """A list of unbilled gas readings for the meterpoint."""
  unbilledReadings: [GasMeterReadingType]
}

"""


This field is a connection type. Connections are used to implement [cursor based
pagination](https://graphql.org/learn/pagination/#pagination-and-edges).


"""
type GasMeterReadingConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [GasMeterReadingConnectionTypeEdge]!
}

"""
A Relay edge containing a `GasMeterReadingConnectionType` and its cursor.
"""
type GasMeterReadingConnectionTypeEdge {
  """The item at the end of the edge"""
  node: GasMeterReadingType

  """A cursor for use in pagination"""
  cursor: String!
}

"""
A gas meter reading. The reading value is under the register collection to be
consistent with electricity readings. We expect a single register and reading value for gas.
"""
type GasMeterReadingType implements MeterReading {
  id: ID!
  readAt: DateTime
  readingSource: String
  registers: [RegisterReading]
  source: String
}

"""Gas registers measure consumption."""
type GasMeterRegisterType {
  id: ID!
  identifier: String
  digits: Int
  decimalPlaces: Int
  name: String
  expectedReadingRanges: [[Int]]
  unitRateType: String
}

"""An enumeration."""
enum GasMeterStatus {
  """Live"""
  LI

  """Faulty"""
  FA

  """Inactive"""
  IN

  """Cut off"""
  CU

  """Clamped"""
  CL

  """Capped"""
  CA

  """Spin Cap"""
  SP

  """Removed"""
  RE

  """Other"""
  OT

  """Unknown"""
  UN

  """Not Installed"""
  NI
}

"""
A gas meter has a register which holds readings. We would expect this to be a
one-to-one relationship between meter and register.
"""
type GasMeterType implements Node & Meter {
  id: ID!
  serialNumber: String!
  requiresAccess: Boolean
  isDigital: Boolean
  installationDate: Date
  lastInspectionDate: Date
  createdAt: DateTime!
  updatedAt: DateTime
  activeFrom: Date!
  activeTo: Date
  meterPoint: GasMeterPointType!
  manufacturerCode: String!
  modelName: String!
  manufacturedYear: Int
  meterType: String!
  imperial: Boolean
  units: Int!
  location: String!
  mechanism: GasMeterMechanism
  correction: Float
  locationDescription: String!
  readingFactor: Decimal
  instructions: String!
  pulseValue: Decimal
  linkCode: String!
  collarFitted: String!
  bypassFitted: String!
  measuringCapacity: Decimal
  status: GasMeterStatus
  operationalStatusDate: Date
  owner: String!
  currentMeterAssetManager: String!
  smartGasMeter: SmartMeterDeviceType

  """The units of consumption for a smart meter."""
  consumptionUnits: String

  """Whether this meter requires a final change of tenancy (COT) reading."""
  requiresCotFinalReading: Boolean

  """Energy consumption recorded by the meter."""
  consumption(
    """Earliest consumption reading to return. Must specify a timezone."""
    startAt: DateTime!

    """Aggregate consumption according to this grouping."""
    grouping: ConsumptionGroupings!

    """Timezone to use for grouping."""
    timezone: String!
    before: String
    after: String
    first: Int
    last: Int
  ): ConsumptionConnection

  """
  This lets us get around the fact that we already use the field id as a primary
  key. We will migrate the id field over to be this id eventually.
  """
  nodeId: ID!
  readings(before: String, after: String, first: Int, last: Int): GasMeterReadingConnectionTypeConnection
  registers: [GasMeterRegisterType]

  """Returns if the meter has and allows half hourly readings"""
  hasAndAllowsHhReadings: Boolean
  smartDevices: [SmartMeterDeviceType]
}

"""An enumeration."""
enum GasMeterTypes {
  """Prepayment."""
  PP

  """Electronic token."""
  ET
}

type GasQuotedProduct {
  label: String!

  """Energy product quoted."""
  product: EnergyProductType!

  """
  Estimated cost in pence of the product over a year based on the quoted usage. 
  """
  annualAmount: Int!

  """
  Estimated cost in pence of the product per month based on the quoted usage.
  """
  monthlyAmount: Int!

  """
  Gas tariff information label (TIL) provides standardised information between suppliers about a tariff.
  """
  gasTariffInformationLabel: ProductTariffInformationLabelStandard!
}

type GasSupplyPoint {
  """The Mprn of the suply point."""
  mprn: String

  """Current active agreement on this supply point."""
  agreement: GasAgreementType

  """Annual consumption of the supply point"""
  annualConsumption: GasConsumption!

  """A list of quoted products and the corresponding tariff information."""
  quotedProducts: [GasQuotedProduct]!

  """Gas has only STANDARD rate type."""
  rateType: String!
}

"""An enumeration."""
enum GasSupplyType {
  """Standard pressure gas supply."""
  STANDARD

  """Medium pressure gas supply."""
  MEDIUM
}

type GasTariffType implements TariffType {
  id: ID
  displayName: String
  fullName: String
  description: String
  productCode: String
  standingCharge: Float
  preVatStandingCharge: Float
  unitRate: Float
  preVatUnitRate: Float
}

"""
Mutation to generate a pre-signed token.

These pre-signed, expiring and opaque tokens will be swapped
for a limited scope JWT (Kraken Token).
"""
type GeneratePreSignedToken {
  token: String
  tokenExpiryDatetime: DateTime
  scope: PreSignedTokenScope
}

"""
The `GenericScalar` scalar type represents a generic
GraphQL scalar value that could be:
String, Boolean, Int, Float, List or Object.
"""
scalar GenericScalar

"""
Get the client secret needed to collect an ad hoc payment using an embedded form.
"""
type GetEmbeddedSecretForAdHocPayment {
  secretKey: String
}

"""
The input for getting the client secret for an embedded one off payment method form.
"""
input GetEmbeddedSecretForAdHocPaymentInput {
  """The account number."""
  accountNumber: String!

  """The amount to be charged."""
  amount: Int!

  """A description of the purpose of the payment."""
  description: String!
}

"""
Get the client secret needed to create a new payment instruction using an embedded form.
"""
type GetEmbeddedSecretForNewPaymentInstruction {
  secretKey: String
}

"""
The input for getting the client secret for an embedded new card payment method form.
"""
input GetEmbeddedSecretForNewPaymentInstructionInput {
  """The account number."""
  accountNumber: String!

  """The type of the new payment instruction."""
  instructionType: PaymentType!
}

type GreenAccomplishmentsType {
  savedTrees: Int
  savedCo2InKgs: Int
}

type HalfHourlyTariff implements TariffType {
  id: ID
  displayName: String
  fullName: String
  description: String
  productCode: String
  standingCharge: Float
  preVatStandingCharge: Float
  unitRates: [UnitRate]
}

"""An enumeration."""
enum HeatPumpQuoteExternalWall {
  """Yes"""
  YES

  """No"""
  NO

  """Not sure"""
  NOT_SURE
}

"""An enumeration."""
enum HeatPumpQuoteStatus {
  """Ineligible"""
  INELIGIBLE

  """On hold"""
  ON_HOLD

  """Ready"""
  READY

  """Consultation completed"""
  CONSULTATION_COMPLETED

  """Home Survey booked"""
  HOME_SURVEY_BOOKED

  """Home Survey completed"""
  HOME_SURVEY_COMPLETED

  """Quote submitted"""
  QUOTE_SUBMITTED

  """Quote adjusted"""
  QUOTE_ADJUSTED

  """Quote accepted"""
  QUOTE_ACCEPTED

  """Advanve paid"""
  ADVANCE_PAID

  """Install booked"""
  INSTALL_BOOKED

  """Installed"""
  INSTALLED

  """In-Life"""
  IN_LIFE
}

"""
Type representing a heat pump quote which contains customer information alongside
property elibility data (EPC).
"""
type HeatPumpQuoteType {
  id: UUID!
  status: HeatPumpQuoteStatus!
  postcode: String!
  waterTank: HeatPumpQuoteWaterTank!
  externalWall: HeatPumpQuoteExternalWall!
  givenName: String!
  familyName: String!
  email: String!
  mobile: String!
  isOwner: Boolean!
  propertyEligibilityUprn: String
  propertyEligibilityData: PropertyEligibilityDataType
}

"""An enumeration."""
enum HeatPumpQuoteWaterTank {
  """Yes"""
  YES

  """No"""
  NO

  """Not sure"""
  NOT_SURE
}

input HotWaterStateInput {
  """Account number."""
  accountNumber: String!

  """
  The state that the hot water device should be set to. A value of true
  indicates that the device should be turned on, and a value of false indicates
  it should be switched off. 
  """
  state: Boolean!
}

type InstallationCapacityType {
  declaredNetCapacity: Decimal!
  extensionReference: String!
  installedCapacity: Decimal!
}

type InstallationType {
  """FIT ID of the installation."""
  fitId: String

  """Details of any meters attached to the installation."""
  meters: [FitMeterType]

  """Address of the property linked to the installation."""
  propertyAddress: PropertyAddressType
}

"""An enumeration."""
enum IntelligentOctopusProviderChoices {
  """Authorise your device with Tesla."""
  TESLA

  """Authorise your device with OCPP Wallbox."""
  OCPP_WALLBOX

  """Authorise your device with Smartcar."""
  SMARTCAR
}

"""
Invalidate a previously issued expiring/pre-signed token.

This mutation can be used to invalidate the token itself.  To
invalidate tokens issued to a particular user, use
InvalidatePreSignedTokensForUser.
"""
type InvalidatePreSignedToken {
  token: PreSignedToken
}

"""Input type for the InvalidatePreSignedToken mutation."""
input InvalidatePreSignedTokenInput {
  token: String!
}

"""
Invalidate pre-signed tokens previously issued to a particular user.

This mutation can invalidate all pre-signed tokens issued to a
customer, or only tokens of a given scope.
"""
type InvalidatePreSignedTokensForUser {
  tokens: [PreSignedToken]
}

"""Input type for the InvalidatePreSignedTokensForUser mutation."""
input InvalidatePreSignedTokensForUserInput {
  """The email address of the user whose tokens should be invalidated."""
  email: String!

  """
  The scope of the token to invalidate.  If this argument is not specified, all
  pre-signed tokens issued to the user are invalidated.
  """
  scope: PreSignedTokenScope
}

"""
Invalidate a previously issued refresh token.

This mutation can be used to invalidate the token itself.  To
invalidate tokens issued to a particular user, use
InvalidateRefreshTokensForUser.
"""
type InvalidateRefreshToken {
  token: RefreshToken
}

"""Input type for the InvalidateRefreshToken mutation."""
input InvalidateRefreshTokenInput {
  refreshToken: String!
}

"""
Invalidate refresh tokens previously issued to a particular user.

This mutation will invalidate all refresh tokens issued to a
customer.
"""
type InvalidateRefreshTokensForUser {
  tokens: [RefreshToken]
}

"""Input type for the InvalidateRefreshTokensForUser mutation."""
input InvalidateRefreshTokensForUserInput {
  """The email address of the user whose tokens should be invalidated."""
  email: String!
}

type InvoiceType implements BillInterface {
  id: ID
  billType: BillTypeEnum
  fromDate: Date
  toDate: Date

  """
  Requesting this field generates a temporary URL at which bill is available.
          This URL will expire after approximately an hour.  It is intended for redirection purposes,
          NOT persistence in any form (e.g. inclusion in emails or the body of a web page).
          This field can raise an error with errorClass NOT_FOUND if the bill document has not
          been created/issued yet.
  
  
          Expected `errorClass`:
  - NOT_FOUND
  - SERVICE_AVAILABILITY
  """
  temporaryUrl: String

  """The date the bill was sent to the customer."""
  issuedDate: Date
}

"""

    Types of devices that can be joined to a HAN (Home Area Network).
    
"""
enum JoinableDeviceType {
  """Electricity meter."""
  ELECTRICITY_METER

  """Gas meter."""
  GAS_METER

  """HAN Connected Auxiliary Load Control Switch (HCALCS)."""
  AUX_SWITCH

  """Pre-Payment Meter Interface Device."""
  PPMID

  """In-Home Display."""
  IHD
}

type JoinConsumerDevice {
  """The reference of the join PPMID or IHD request in Kraken."""
  requestReference: String
}

"""An enumeration."""
enum JoinConsumerDeviceChoices {
  """Pre-Payment Meter Interface Device."""
  PPMID

  """In-Home Display."""
  IHD
}

input JoinConsumerDeviceInput {
  """The fuel type of the device, electricity, gas or dual fuel"""
  fuelType: FuelTypeChoices!

  """Device ID of the CHF (Communications Hub Function)."""
  chfDeviceId: String!

  """Device ID (IHD or PPMID) of the device being commissioned."""
  consumerDeviceId: String!

  """
  Code provided by manufacturer as part of ASN data, and included as part of
  device pre-notification, which is required to authorise device commissioning.
  """
  installationCode: String

  """The device type being joined to the CHF."""
  consumerDeviceType: JoinConsumerDeviceChoices!
}

"""
Send a request to the DCC to join a smart device to a HAN (Home Area Network).
"""
type JoinDeviceToNetwork {
  requestReference: String
}

"""
Allows use of a JSON String for input / output from the GraphQL schema.

Use of this type is *not recommended* as you lose the benefits of having a defined, static
schema (one of the key benefits of GraphQL).
"""
scalar JSONString

type KrakenFlexDeviceType {
  krakenflexDeviceId: String
  vehicleMake: String
  vehicleModel: String
  vehicleBatterySizeInKwh: Decimal
  chargePointMake: String
  chargePointModel: String
  chargePointPowerInKw: Decimal
  status: String
  suspended: Boolean
  hasToken: Boolean
  createdAt: DateTime
}

interface LedgerInterface {
  id: Int

  """The display name of the ledger."""
  name: String
  ledgerType: String

  """The current balance on the ledger in minor units of currency."""
  balance: Int

  """Whether this ledger's balance contributes to the account's balance."""
  affectsAccountBalance: Boolean
}

"""
Ledgers provide the foundation of Kraken’s bookkeeping functionality. Similar to
a bank account, they allow us to keep track of financial activity on a
particular Kraken account.
"""
type LedgerType implements LedgerInterface {
  id: Int

  """The display name of the ledger."""
  name: String

  """The ledger type code."""
  ledgerType: String

  """The current balance on the ledger in minor units of currency."""
  balance: Int

  """Whether this ledger's balance contributes to the account's balance."""
  affectsAccountBalance: Boolean
}

"""


This field is a connection type. Connections are used to implement [cursor based
pagination](https://graphql.org/learn/pagination/#pagination-and-edges).


"""
type LineItemConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [LineItemEdge]!
}

"""A Relay edge containing a `LineItem` and its cursor."""
type LineItemEdge {
  """The item at the end of the edge"""
  node: LineItemType

  """A cursor for use in pagination"""
  cursor: String!
}

"""An enumeration."""
enum LineItemGroupingOptions {
  NONE
  HALF_HOUR
  HOUR
  DAY
  WEEK
  MONTH
  QUARTER
}

"""A record of spend on consumption between two points in time."""
type LineItemType {
  startAt: DateTime
  endAt: DateTime
  netAmount: Decimal
  numberOfUnits: Decimal
  itemType: String
  settlementUnit: String
}

"""An enumeration."""
enum LineItemTypeOptions {
  STANDING_CHARGE
  CONSUMPTION_CHARGE
}

enum LinkedObjectType {
  ACCOUNT
  ACCOUNT_USER
}

"""An enumeration."""
enum LinkTrainingStatus {
  """Not applicable"""
  NOT_APPLICABLE

  """In training"""
  IN_TRAINING

  """Qualified"""
  QUALIFIED
}

type MasqueradeAuthentication {
  token: String
  errors: [ErrorType]
}

"""An enumeration."""
enum MaximumRefundReasonChoices {
  """
  Maximum refund is equal to the current balance minus the account recommended balance.
  """
  MAX_AVAILABLE_AMOUNT

  """
  Maximum refund is equal to the total amount the customer has paid using the current account Direct Debit instruction.
  """
  TOTAL_AMOUNT_PAID_VIA_ACTIVE_DDI

  """
  Maximum refund is equal to the maximum refund amount allowed to be requested via the dashboard.
  """
  MAX_ALLOWED_TO_REQUEST_VIA_DASHBOARD
}

type MaximumRefundType {
  """The maximum amount available to be requested as a refund."""
  amount: Int

  """
  The reason why a specific amount is the maximum available to be requested as a refund.
  """
  reasonToRecommendAmount: MaximumRefundReasonChoices

  """
  The recommended minimum balance an account should have when asking for a refund.
  """
  recommendedBalance: Int
}

type Metadata {
  """The key for the metadata."""
  key: String!

  """The metadata value."""
  value: JSONString
}

"""The metadata input type for mutations."""
input MetadataInput {
  """
  An identifier for the associated object, e.g. account_number for the Account linked object type.
  """
  identifier: String!

  """The object that the metadata is associated with."""
  linkedObjectType: LinkedObjectType!

  """The key for the metadata."""
  key: String!

  """The metadata value which should be a valid JSON string."""
  value: JSONString!
}

interface Meter {
  id: ID!
  serialNumber: String!

  """The units of consumption for a smart meter."""
  consumptionUnits: String

  """Whether this meter requires a final change of tenancy (COT) reading."""
  requiresCotFinalReading: Boolean

  """Energy consumption recorded by the meter."""
  consumption(
    """Earliest consumption reading to return. Must specify a timezone."""
    startAt: DateTime!

    """Aggregate consumption according to this grouping."""
    grouping: ConsumptionGroupings!

    """Timezone to use for grouping."""
    timezone: String!
    before: String
    after: String
    first: Int
    last: Int
  ): ConsumptionConnection
}

input MeterInput {
  """Serial number of the meter involved in the appointments"""
  serialNumber: String!

  """
  Whether the meter details refer to a meter that is currently installed at the
  site or one that has been removed or replaced.
  """
  status: MeterStatus

  """
  The type of meter. This field is not required but should be supplied whenever possible.
  """
  meterType: String
}

interface MeterPointInterface {
  status: String

  """
  Returns active meters by default, but can be filtered by meter id and active status.
  """
  meters(id: Int, includeInactive: Boolean): [Meter]

  """Details of an ongoing enrolment process."""
  enrolment: EnrolmentType
}

interface MeterReading {
  readAt: DateTime
  readingSource: String
  registers: [RegisterReading]
  source: String
}

"""
Represents groupings of meter reading events Meter readings can be filtered by these event types.
"""
enum MeterReadingEventType {
  CUSTOMER
  SMART_METER
  ESTIMATE
  CHANGE_OF_SUPPLY
  METER_EXCHANGE
  PREPAY
  PRE_SUPPLIER
  DATA_COLLECTOR
}

"""An enumeration."""
enum MeterStatus {
  """The meter was removed."""
  REMOVED

  """The meter was installed or work was done on an existing meter."""
  ON_SITE
}

"""An enumeration."""
enum MeterTypeChoices {
  """Electricity meter."""
  ELECTRICITY_METER

  """Gas meter."""
  GAS_METER
}

input MoveInNewProperty {
  address: String!
  postcode: String!
  moveInDate: String!
  mpans: [String]!
  mprns: [String]!
}

input MoveOutInput {
  accountNumber: String!
  propertyId: String!
  moveOutDate: Date!

  """The property to perform a move in for."""
  newProperty: MoveInNewProperty

  """The details of the next occupant of the property."""
  newTenant: MoveOutNewTenant
}

input MoveOutNewTenant {
  givenName: String
  familyName: String
  email: String
  mobile: String
  role: String
}

"""
Mutations are the GraphQL equivalent of POST requests in REST. By convention,
they are used when data is mutated on the server. To learn about how to form
Mutations in graphql, see [GraphQL's
documentation](https://graphql.org/learn/queries/#mutations).

⬅️ This interface will autocomplete, so just try typing what you want. You can
also search these docs. Some mutations will require authentication. Check the
documentation or search `Authentication` for details.
"""
type Mutation {
  """
  Submit meter readings for any FIT installations associated with a particular account.
  """
  fitCreateMeterReadings(input: FitMeterReadingInput!): FitCreateMeterReadings

  """Add a refund request to an account."""
  createRefundRequest(
    """Input fields for creating a refund request."""
    input: RefundRequestInput!
  ): CreateRefundRequest

  """
  Update smart meter data preferences of an account. Includes updating reading frequency and readings analysis consent.
  """
  updateSmartMeterDataPreferences(
    """Input fields for updating smart meter data preferences."""
    input: UpdateSmartMeterDataPreferencesInput!
  ): UpdateSmartMeterDataPreferences

  """Adds a new device schedule and dispatches to device."""
  createDeviceSchedule(
    """On/off schedule to be dispatched to the SMETS2 device."""
    schedule: DeviceScheduleInput!
  ): CreateDeviceSchedule

  """Joins a device to a HAN (Home Area Network)."""
  joinDeviceToNetwork(
    """Device ID of the CHF (Communications Hub Function)."""
    chfDeviceId: String!

    """Code that authorises joining of the device to the HAN."""
    installCode: String

    """MPAN/MPRN of the meter or HCALCS to join to the HAN."""
    mpxn: String

    """Device ID of the device to join to the HAN."""
    newDeviceId: String!

    """Type of device that is being joined to the HAN."""
    newDeviceType: JoinableDeviceType!
  ): JoinDeviceToNetwork

  """Commissions the device after the meter has been physically installed."""
  commissionMeter(
    """Input fields for commission meters."""
    input: CommissionMeterInput!
  ): CommissionMeter

  """
  Decommissions a device using SmartPear's 'remove device' orchestration.
  """
  decommissionSmartDevice(
    """Input fields for decommission meters."""
    input: DecommissionSmartDeviceInput!
  ): DecommissionSmartDevice

  """Notify Kraken to run the relevant prenotifications for a new device."""
  registerSmartDevice(
    """Specifies device metadata to use for prenotifications."""
    input: RegisterSmartDeviceInput!
  ): RegisterSmartDevice

  """Update the status of the CHF (Communictions Hub)."""
  updateCommsHubStatus(
    """Input fields for updating the status of the communications hub."""
    input: UpdateCommsHubStatusInput!
  ): UpdateCommsHubStatus

  """
  Calls the orchestration to join the PPMID or IHD device to the ESME, GSME, GPF
  and CHF.This should be called after a meter has been commissioned.
  """
  joinConsumerDevice(
    """Input fields for join device."""
    input: JoinConsumerDeviceInput!
  ): JoinConsumerDevice

  """Add credit to a smart prepay meter"""
  addCreditToSmartMeter(
    """Controls which meter to top-up and by how much."""
    input: SmartPrepayMeterAmountInput!
  ): AddCreditToSmartMeter

  """Create a payment intent."""
  createPaymentIntent(
    """Input fields for creating a payment intent."""
    input: CreatePaymentIntentInput!
  ): CreatePaymentIntent

  """
  Add details to an existing occupier account.
  
  Expected `errorClass`:
  - NOT_FOUND
  """
  occupy(input: OccupyInput!): OccupyOutputType

  """
  Perform a move out of a property for an account.
  
  Optionally provide details of the new tenant and a property to perform a move in to.
  
  Expected `errorClass`:
  - VALIDATION
  - AUTHORIZATION
  - APPLICATION
  """
  performMoveOut(input: MoveOutInput!): PerformMoveOut

  """Create a shell/payment account."""
  createShellAccount(input: CreateShellAccountInput!): CreateShellAccountPayload

  """Update account communication delivery preference."""
  updateCommsDeliveryPreference(
    """Input fields for updating comms delivery preferences for an account"""
    input: UpdateCommsDeliveryPreferenceInput!
  ): UpdateCommsDeliveryPreference

  """Renew agreements for an account."""
  renewAgreements(input: RenewAgreementsInput): RenewAgreements

  """Renew agreement for a meter point"""
  renewAgreementForMeterPoint(input: RenewAgreementForMeterPointInput!): RenewAgreementForMeterPoint

  """Renew a list of agreements for an account."""
  renewAgreementsForAccount(input: RenewAgreementsForAccountInput): RenewAgreementsForAccount

  """Set stated interest in procuring a smart meter for an account."""
  smets2Interest(input: UpdateAccountSmartMeterInterestInput): UpdateAccountSmartMeterInterest

  """Start smart onboarding process for an account."""
  startOnboardingProcess(input: StartSmartOnboardingProcessInput): StartSmartOnboardingProcess

  """Start export onboarding process for an account."""
  startExportOnboardingProcess(input: StartExportOnboardingProcessInput): StartExportOnboardingProcess

  """Create a Siteworks event."""
  createSiteworksEvent(
    """Input fields for creating a new Siteworks event."""
    input: CreateSiteworksEventInput!
  ): CreateSiteworksEvent

  """Allow external parties to create a Siteworks event."""
  createSiteworksEventExternal(
    """Input fields for creating a new Siteworks event."""
    input: CreateSiteworksEventInput!
  ): CreateSiteworksEventExternal

  """Create or update a Siteworks appointment."""
  createOrUpdateSiteworksAppointment(
    """Input fields for creating or updating siteworks appointments."""
    input: CreateOrUpdateSiteworksAppointmentInput!
  ): CreateOrUpdateSiteworksAppointment

  """Cancel a Siteworks appointment."""
  cancelSiteworksAppointment(
    """Input fields for cancelling a siteworks appointment."""
    input: CancelSiteworksAppointmentInput!
  ): CancelSiteworksAppointment

  """Confirm an appointment slot returned by the appointment slots query."""
  confirmSiteworksAppointmentSlot(
    """Input fields for booking a siteworks appointment slot"""
    input: ConfirmSiteworksAppointmentSlotInput!
  ): ConfirmSiteworksAppointmentSlot

  """
  Report details, readings and balances of meters removed during install.
  """
  reportRemovedMeterDetails(
    """Input fields for removed meter details."""
    input: ReportRemovedMeterDetailsInput!
  ): ReportRemovedMeterDetails

  """
  Update or create special circumstances for the user, which may entitle them to specialist services
  
  Expected `errorClass`:
  - VALIDATION
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  updateSpecialCircumstances(input: UpdateSpecialCircumstancesInput!): UpdateSpecialCircumstances

  """
  **DEPRECATED: Please use updatePaymentSchedulePaymentDay instead**
  
  Update monthly Direct Debit payment day
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  directDebitPaymentDayUpdate(input: DirectDebitPaymentDayUpdateInput!): DirectDebitPaymentDayUpdate

  """
  Update monthly Direct Debit payment day. Permitted values: 1-28. Not available for business accounts
  
  Expected `errorClass`:
  - APPLICATION
  - AUTHORIZATION
  - VALIDATION
  - NOT_FOUND
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  updatePaymentSchedulePaymentDay(input: UpdatePaymentSchedulePaymentDayInput!): UpdatePaymentSchedulePaymentDay

  """
  **DEPRECATED: Please use updatePaymentSchedulePaymentAmount instead**
  
  Update monthly Direct Debit payment amount. Enter amount in penceLower limit: 100p (£1) , Upper limit: 100,000p (£1,000)
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  directDebitPaymentAmountUpdate(input: DirectDebitPaymentAmountInput!): DirectDebitPaymentAmountUpdate

  """
  Create new direct debit instruction
  
  Expected `errorClass`:
  - VALIDATION
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  createDirectDebitInstruction(
    """Input fields for creating a new direct debit instruction"""
    input: CreateDirectDebitInstructionInput!
  ): CreateDirectDebitInstruction

  """
  Update monthly Direct Debit payment amount. Enter amount in pence
  
  Lower limit: 100p (£1), Upper limit: 100,000p (£1,000)
  
  Expected `errorClass`:
  - VALIDATION
  - APPLICATION
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  updatePaymentSchedulePaymentAmount(input: UpdatePaymentSchedulePaymentAmountInput!): UpdatePaymentSchedulePaymentAmount

  """
  Create a monthly payment schedule for a fixed amount.
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  createPaymentSchedule(input: PaymentScheduleInput!): CreatePaymentSchedule

  """
  Create warm home discount application with given qualifying requirements and account.
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  createWarmHomeDiscountApplication(accountNumber: String, applicationInputs: WarmHomeDiscountApplicationInputType): WarmHomeDiscountApplicationOutputType

  """
  Create electricity meter reading(s) with the given value(s) for the given meter(s).
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  createElectricityMeterReading(mpan: String, readAt: Date, readings: [ReadingInputType], serialNumber: String): CreateMeterReadingOutputType

  """
  Create gas meter reading with the given value for the given meter.
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  createGasMeterReading(mprn: String, readAt: Date, reading: Int, serialNumber: String): CreateMeterReadingOutputType

  """Amend unbilled electricity readings."""
  amendUnbilledElectricityReading(
    """Input fields for amending unbilled electricity reading."""
    input: AmendUnbilledReadingInput!
  ): AmendUnbilledElectricityReading

  """
  Create a quote for the given set of meter points for the supplied consumption.
  """
  createQuote(input: CreateQuoteInput!): CreateQuoteOutputType

  """Requote for an account property."""
  requote(input: RequoteInput!): Requote

  """
  **DEPRECATED: Please use updateUser instead**
  
  Update the account user details of the authenticated user. Only one field can
  be updated per day. This prevents users from switching accounts to someone
  else (usually when moving homes) All account changes should be handled by
  operations or the move out journey. New customers are exempt from this rule
  for the first 31 days.
  """
  updateUserDetails(input: UpdateAccountUserMutationInput!): UpdateAccountUserMutationPayload

  """
  Update the comms preferences of the account user (the authenticated user).
  """
  updateCommsPreferences(input: UpdateAccountUserCommsPreferencesMutationInput!): UpdateAccountUserCommsPreferencesMutationPayload

  """
  Update password of the authenticated user.
  
  Expected `errorClass`:
  - VALIDATION
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  updatePassword(input: UpdatePasswordInput): UpdatePassword

  """
  Update the account user details of the authenticated user. Only one field can
  be updated per day. This prevents users from switching accounts to someone
  else (usually when moving homes) All account changes should be handled by
  operations or the move out journey. New customers are exempt from this rule
  for the first 31 days.
  
  Expected `errorClass`:
  - VALIDATION
  - AUTHORIZATION
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  updateUser(
    """Input fields for updating user."""
    input: UpdateUserInput!
  ): UpdateUserMutation

  """
  Register a device token to be used for push notifications for an app.
  
  Expected `errorClass`:
  - APPLICATION
  - NOT_FOUND
  - AUTHORIZATION
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  registerPushNotificationBinding(
    """Input fields for creating an push notification binding."""
    input: RegisterPushNotificationBindingInput!
  ): RegisterPushNotificationBinding

  """Create an Electric Juice agreement for an account."""
  createElectricJuiceAgreement(
    """Input fields for creating an Electric Juice agreement for an account."""
    input: CreateElectricJuiceAgreementInput!
  ): CreateElectricJuiceAgreement

  """Create an Electric Juice charge card for an account."""
  createElectricJuiceChargeCard(
    """Input fields for creating an Electric Juice charge card."""
    input: CreateElectricJuiceChargeCardInput!
  ): CreateElectricJuiceChargeCard

  """Store a new card instruction for Electric Juice from an embedded form."""
  storeElectricJuicePaymentInstruction(
    """Input fields for storing a new card instruction from an embedded form."""
    input: StoreElectricJuicePaymentInstructionInput!
  ): StoreElectricJuicePaymentInstruction

  """Add a charge for Electric Juice."""
  createElectricJuiceCharge(
    """Input fields for creating an account charge."""
    input: CreateElectricJuiceChargeInput!
  ): CreateElectricJuiceCharge

  """Add a credit for Electric Juice"""
  createElectricJuiceCredit(
    """Input fields for creating an Electric Juice credit."""
    input: CreateElectricJuiceCreditInput!
  ): CreateElectricJuiceCredit

  """Register a device for an account."""
  registerDevice(input: RegisterDeviceInput): RegisterDevice

  """Set charging preferences for your electric vehicle."""
  setVehicleChargePreferences(input: VehicleChargingPreferencesInput): SetVehicleChargingPreferences

  """Perform a test charge for your electric vehicle."""
  triggerTestCharge(input: AccountNumberInput): PerformTestCharge

  """Perform an emergency boost charge for your electric vehicle."""
  triggerBoostCharge(input: AccountNumberInput): PerformBoostCharge

  """Stop any active boost charging."""
  deleteBoostCharge(input: DeleteBoostChargeInput): DeleteBoostCharge

  """Suspend control of the device."""
  suspendControl(input: AccountNumberInput): SuspendDeviceControl

  """Resume control of the device."""
  resumeControl(input: AccountNumberInput): ResumeDeviceControl

  """Delete connection details for a device."""
  deleteDeviceConnectionDetails(input: AccountNumberInput): DeleteDeviceConnectionDetails

  """Authenticate via OCPP-Wallbox."""
  ocppAuthentication(input: OCPPAuthenticationInput): OCPPAuthentication

  """Turn a hot water device on or off."""
  setRoomTemperature(input: RoomTemperatureInput): SetRoomTemperature

  """Turn a hot water device on or off."""
  setHotWaterState(input: HotWaterStateInput): SetHotWaterState

  """Turn a hot water device on or off."""
  setClimateControlState(input: ClimateControlStateInput): SetClimateControlState

  """Set stated winter workout goal for an account."""
  setAccountWinterWorkoutGoal(input: SetAccountWinterWorkoutGoalInput): SetAccountWinterWorkoutGoal

  """Set winter workout tips for an account."""
  setAccountWinterWorkoutTips(input: SetAccountWinterWorkoutTipsInput): SetAccountWinterWorkoutTips
  createAccountFileAttachment(input: CreateAccountFileAttachmentInput!): CreateAccountFileAttachmentPayload!
  triggerPostUploadOperations(s3Key: String!): TriggerPostUploadOperations!

  """Create an affiliate link for a new sales agent."""
  createAffiliateLink(
    """Input fields for creating an affiliate link for an organisation"""
    input: CreateAffiliateLinkInputType!
  ): CreateAffiliateLink!

  """Update an existing affiliate link."""
  updateAffiliateLink(
    """Input fields for Updating an existing affiliate link"""
    input: UpdateAffiliateLinkInputType!
  ): UpdateAffiliateLink!

  """Validate user's email address"""
  validateEmail(input: ValidateEmailInput!): ValidateEmail

  """Create metadata on an object."""
  createMetadata(
    """Input fields for creating metadata."""
    input: MetadataInput!
  ): CreateMetadata

  """Update metadata on an object."""
  updateMetadata(
    """Input fields for updating metadata."""
    input: MetadataInput!
  ): UpdateMetadata

  """
  Submit customer feedback.Expected `errorClass`:
  - NOT_FOUND
  - VALIDATION
  """
  submitCustomerFeedback(input: CustomerFeedbackInputType!): SubmitCustomerFeedback

  """Collect deposit for the given account."""
  collectDeposit(input: CollectDepositInput!): CollectDeposit

  """Record the customer's acceptance of a deposit agreement."""
  recordDepositAgreementAccepted(input: DepositAgreementInput!): RecordDepositAgreementAccepted

  """Create a new deposit agreement for the account if it needs one."""
  createDepositAgreement(input: CreateDepositAgreementInput!): CreateDepositAgreement

  """
  Get the client secret needed to create a new payment instruction using an embedded form.
  """
  getEmbeddedSecretForNewPaymentInstruction(
    """
    Input fields for getting the client secret for an embedded new card payment method form.
    """
    input: GetEmbeddedSecretForNewPaymentInstructionInput!
  ): GetEmbeddedSecretForNewPaymentInstruction

  """
  Get the client secret needed to collect an ad hoc payment using an embedded form.
  """
  getEmbeddedSecretForAdHocPayment(
    """
    Input fields for getting the client secret for an embedded one off payment form.
    """
    input: GetEmbeddedSecretForAdHocPaymentInput!
  ): GetEmbeddedSecretForAdHocPayment

  """Store a new card instruction from an embedded form."""
  storeCardPaymentInstruction(
    """Input fields for storing a new card instruction from an embedded form."""
    input: StoreCardPaymentInstructionInput!
  ): StoreCardPaymentInstruction

  """Create an account reference."""
  createAccountReference(
    """Input fields for creating an account reference."""
    input: AccountReferenceInput!
  ): CreateAccountReference

  """Update an account reference."""
  updateAccountReference(
    """Input fields for updating an account reference."""
    input: AccountReferenceInput!
  ): UpdateAccountReference

  """Add credit to an account."""
  createAccountCredit(
    """Input fields for creating an account credit."""
    input: CreateAccountCreditInput!
  ): CreateAccountCredit

  """Add charge to an account."""
  createAccountCharge(
    """Input fields for creating an account charge."""
    input: CreateAccountChargeInput!
  ): CreateAccountCharge

  """
  Create a "form submission" entity. This is only meant to be used as a quick
  way of putting together a form and submit data for it, in the form of JSON -
  it is not expected that all form submissions will come through this path.
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  createFormSubmission(input: FormSubmissionInput!): FormSubmissionOuput

  """
  Provide username and password to receive a token. The token should be used as
  the Authentication header for any authenticated requests.
  """
  emailAuthentication(email: String!, password: String!): EmailAuthentication @deprecated(reason: "Please use obtainKrakenToken instead of this mutation.")

  """
  You probably want email authentication instead of this. Provide user's API Key
  to receive a token. The token should be used as the Authentication header for
  any authenticated requests. This form of authentication is used when the
  interface in question already has the API Key and it would be inappropriate to
  show the user a login screen.
  """
  apiKeyAuthentication(apiKey: String!): APIKeyAuthentication @deprecated(reason: "Please use obtainKrakenToken instead of this mutation.")

  """
  Provide a temporary token to get an auth token. This is intended to allow
  support users to view customer data through the brand interface.
  """
  masqueradeAuthentication(masqueradeToken: String!, userId: String!): MasqueradeAuthentication

  """Generate a pre-signed token with a set expiry time."""
  generatePreSignedToken(
    email: String!

    """
    The number of days that the token will be available for authentication (From now on).
    """
    numberOfDaysAllowed: Int!

    """Define (and limit) the scope of the token."""
    scope: PreSignedTokenScope!
  ): GeneratePreSignedToken

  """Invalidate a previously-issued pre-signed token."""
  invalidatePreSignedToken(input: InvalidatePreSignedTokenInput!): InvalidatePreSignedToken

  """Invalidate pre-signed tokens issued to a particular user."""
  invalidatePreSignedTokensForUser(input: InvalidatePreSignedTokensForUserInput!): InvalidatePreSignedTokensForUser

  """Deactivate the auth token used to authenticate the current request."""
  disableToken: DisableToken

  """
  Provide the email address of an account user to generate an email (to be sent
  to their address). The email will contain instructions on how to reset their password.
  """
  requestResetPassword(input: RequestResetPasswordMutationInput!): RequestResetPasswordMutationPayload

  """
  Reset the password of an account user indicated by the userId to the value supplied.
  """
  resetPassword(input: ResetPasswordMutationInput!): ResetPasswordMutationPayload

  """
  Create a JSON Web Token (JWT) for authentication.  
  
  Provide username and password to receive a token. The token should be used as
  the Authentication header for any authenticated requests. 
  
  The keyword JWT must be added in front of the token. 
  
  Example:
  
  JWT eyJ0eXAiOiJKVBd....
  """
  createAuthenticationToken(email: String!, password: String!): ObtainJSONWebToken @deprecated(reason: "Please use obtainKrakenToken instead of this mutation.")

  """Verify the authentication JSON Web Token (JWT)."""
  verifyAuthenticationToken(token: String): Verify

  """Refresh the authentication JSON Web Token (JWT)."""
  refreshAuthenticationToken(refreshToken: String): Refresh

  """
  Create a Kraken Token (JWT) for authentication.  
  
  Provide the required input fields to obtain the token. 
  
  The token should be used as the Authentication header for any authenticated requests. 
  
  The keyword JWT must be added in front of the token. 
  
  Example:
  
  JWT eyJ0eXAiOiJKVBd....
  """
  obtainKrakenToken(
    """
    Input fields that can be used to obtain a Json Web Token (JWT) for authentication to the API.
    """
    input: ObtainJSONWebTokenInput!
  ): ObtainKrakenJSONWebToken

  """For authorized third-party organizations only."""
  obtainLongLivedRefreshToken(
    """
    Input fields for obtaining a long-lived refresh token to extend the expiry claim of a Kraken token.
    """
    input: ObtainLongLivedRefreshTokenInput!
  ): ObtainLongLivedRefreshToken

  """Invalidate a previously-issued refresh token."""
  invalidateRefreshToken(input: InvalidateRefreshTokenInput!): InvalidateRefreshToken

  """Invalidate refresh tokens issued to a particular user."""
  invalidateRefreshTokensForUser(input: InvalidateRefreshTokensForUserInput!): InvalidateRefreshTokensForUser
}

"""An enumeration."""
enum NewMeterCategory {
  """SMETS1 (first generation smart meter)."""
  SMETS1

  """SMETS2 (second generation smart meter)."""
  SMETS2

  """Traditional meter."""
  TRADITIONAL

  """Check Meter."""
  CHECK_METER
}

"""An object with an ID"""
interface Node {
  """The ID of the object."""
  id: ID!
}

"""An enumeration."""
enum NonBespokeElectricityRateTypeChoices {
  STANDARD
  ECO7_DAY
  ECO7_NIGHT
  OFF_PEAK
}

"""An enumeration."""
enum NotifiableApplicationExternalProvider {
  """AWS Pinpoint"""
  PINPOINT
}

"""An enumeration."""
enum NotifiableApplicationService {
  """Android (GCM)"""
  GCM

  """iOS (APNs)"""
  APNS

  """iOS Sandbox (APNs Sandbox)"""
  APNS_SANDBOX
}

"""Represents an application that can receive push notifications."""
type NotifiableApplicationType {
  id: ID!

  """Human readable name for the app."""
  name: String!

  """Bundle ID or package name of the app."""
  bundleId: String!
  service: NotifiableApplicationService!
  externalProvider: NotifiableApplicationExternalProvider!

  """
  Project ID used in push notification delivery service. (Currently: AWS Pinpoint)
  """
  externalProjectId: String!
  description: String!
  pushNotificationBindings: [PushNotificationBindingType!]!
}

type ObtainJSONWebToken {
  payload: GenericScalar!
  refreshExpiresIn: Int!
  token: String!
  refreshToken: String!
}

"""The input type for obtaining a Kraken Token (JWT)."""
input ObtainJSONWebTokenInput {
  """Email address of the account user. Use with 'password' field."""
  email: String

  """Password of the account user. Use with 'email' field."""
  password: String

  """
  API key of the account user. Use standalone, don't provide a second input field.
  """
  APIKey: String

  """
  Live secret key of an third-party organization. Use standalone, don't provide a second input field.
  """
  organizationSecretKey: String

  """
  Short-lived, temporary key (that's pre-signed). Use standalone, don't provide a second input field.
  """
  preSignedKey: String

  """
  The refresh token that can be used to extend the expiry claim of a Kraken
  token. Use standalone, don't provide a second input field.
  """
  refreshToken: String
}

"""
The unifying approach used to get a Kraken token (JWT: JSON Web Token) with
different types of input.

The currently supported inputs are:
- account user email/password combination
- account user API key
- organization live secret key
- pre-signed key
- refresh token
"""
type ObtainKrakenJSONWebToken {
  token: String!
  payload: GenericScalar!
  refreshToken: String
  refreshExpiresIn: Int
}

"""
Obtain a long-lived refresh token.

This mutation is limited to authorized third-party organizations only.

Account users can only generate short-lived refresh tokens.

The short-lived refresh tokens (for account users) can be obtained from
the 'refreshToken' field in 'obtainKrakenToken' mutation.
"""
type ObtainLongLivedRefreshToken {
  refreshToken: String
  refreshExpiresIn: Int!
}

"""The input type for obtaining a long-lived refresh token."""
input ObtainLongLivedRefreshTokenInput {
  """
  The Kraken Token that will be used to generate the long-lived refresh token.
  """
  krakenToken: String!
}

"""An occupancy period for a property."""
type OccupancyPeriodType {
  effectiveFrom: DateTime
  effectiveTo: DateTime
}

type OccupierAccount {
  account: String!
  address: String!
  date: String!
  propertyId: Int!
}

input OccupyInput {
  accountNumber: String!
  propertyId: String!
  quoteCode: String!
  productCode: String!

  """
  The day of the month that payments should be taken from the account. Should be between 1 and 28.
  """
  paymentDay: Int
  directDebitInstruction: DirectDebitInstructionLocalBankDetailsInput
  users: [AccountUserInput]
  moveInDate: Date
}

type OccupyOutputType {
  account: AccountInterface
}

"""
Open Charge Point Protocol (OCPP) authentication.

Take the given password (OCPP authentication details), salt and hash it, then forward the hashed value
to KrakenFlex, so that they can compare the hashed password with what they are getting from OCPP.
"""
type OCPPAuthentication {
  krakenflexDevice: KrakenFlexDeviceType
}

input OCPPAuthenticationInput {
  """Account number."""
  accountNumber: String!

  """The OCPP authentication details."""
  details: String!
}

type OCPPDetailsType {
  url: String
  username: String
}

"""
The Relay compliant `PageInfo` type, containing data necessary to paginate this connection.
"""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

"""A payment from the customer to the energy supplier."""
type Payment implements TransactionType {
  id: ID
  postedDate: Date

  """Gross amount including tax whenever tax is payable."""
  amount: Int

  """
  The customer's resulting balance in pence after this transaction has been applied.
  """
  balanceCarriedForward: Int

  """Deprecated"""
  isCredit: Boolean

  """Deprecated"""
  isAccountCharge: Boolean

  """Deprecated"""
  isAccountPayment: Boolean

  """
  Whether the statement this transaction is on has been held. A held statement
  is not sent to a customer automatically, but is instead marked for manual
  attention by operations staff.
  """
  isHeld: Boolean
  title: String
  statementId: ID
  isReversed: Boolean!
}

type PaymentAdequacyType {
  """
  The suggested monthly payment amount in pence following the payment adequacy review.
  """
  suggestedDirectDebitAmount: Int
}

type PaymentForecastType {
  paymentNumber: Int
  date: Date
  amount: Int
}

"""An enumeration."""
enum PaymentFrequencyOptions {
  """Daily"""
  Daily

  """Weekly"""
  Weekly

  """Monthly"""
  Monthly
}

"""Payment Instructions"""
type PaymentInstructionType {
  id: ID!
  status: String!
  sortCode: String!
  iban: String!
  accountHolder: String!
  instructionType: String
  cardPaymentNetwork: String
  cardExpiryMonth: Int
  cardExpiryYear: Int
  validFrom: DateTime!

  """
  The provider to use for this DDI. Most accounts would have SmartDebit as their provider, Iresa customers use GoCardless
  """
  vendor: String!
  cardNumber: String!
  cardType: String

  """A masked reference to a recurring payment method."""
  maskedAccountIdentifier: String
}

type PaymentIntentType {
  id: ID!

  """A unique identifier for this payment intent."""
  reference: String!
  accountNumber: String
  amount: Int
  date: Date
}

"""An enumeration."""
enum PaymentMethodChoices {
  """Direct Debit Monthly."""
  DIRECT_DEBIT_MONTHLY

  """Pay on receipt of bill."""
  POROB

  """Prepayment."""
  PREPAYMENT
}

"""

    The mode used by a SMETS2 meter to charge for energy consumed.

    Energy consumption can either be paid for in advance (i.e. prepay / pay-as-you-go)
    or at some time later (i.e. credit).
    
"""
enum PaymentMode {
  """Prepayment."""
  PREPAY

  """Credit."""
  CREDIT
}

type PaymentScheduleConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PaymentScheduleConnectionTypeEdge]!
}

"""
A Relay edge containing a `PaymentScheduleConnectionType` and its cursor.
"""
type PaymentScheduleConnectionTypeEdge {
  """The item at the end of the edge"""
  node: PaymentScheduleType

  """A cursor for use in pagination"""
  cursor: String!
}

input PaymentScheduleInput {
  """Input a customer account number."""
  accountNumber: String!

  """Payment amount must be inputted as pence."""
  paymentAmount: Int!

  """Input a direct debit payment day."""
  paymentDay: Int!
}

"""An enumeration."""
enum PaymentScheduleReasonOptions {
  """The default value for usual account payments."""
  GENERAL_ACCOUNT_PAYMENT

  """
  A payment schedule created to take a payment around the supply start date of a
  meterpoint to help prevent accounts accruing debt.
  """
  SSD_PAYMENT

  """
  A payment schedule created to take the final payment when an account is closed.
  """
  FINAL_PAYMENT

  """
  A payment schedule created to take payments to pay back a debt. These
  schedules typically expire once the debt has been re-payed.
  """
  DEBT_REPAYMENT_PLAN
}

"""An enumeration."""
enum PaymentScheduleScheduleType {
  """Manual payment"""
  BACS_TRANSFER

  """Card payment"""
  CARD_PAYMENT

  """Direct debit"""
  DIRECT_DEBIT
}

"""
An object that represents when we have agreed to take payments from a payment instruction.
"""
type PaymentScheduleType {
  id: ID!

  """The supplementary ledger for this payment schedule, if it is on one"""
  supplementaryLedger: SupplementaryLedgerType
  validFrom: Date!
  validTo: Date

  """The reason the payment schedule was created."""
  reason: PaymentScheduleReasonOptions
  isPaymentHoliday: Boolean!
  paymentHolidayReason: String!
  paymentDay: Int!

  """The frequency of the payment schedule"""
  paymentFrequency: PaymentFrequencyOptions
  paymentFrequencyMultiplier: Int!
  paymentAmount: Int!
  paymentAdequacyAdjustment: Int
  paymentAdequacyAdjustmentExpiryDate: Date
  isVariablePaymentAmount: Boolean!
  scheduleType: PaymentScheduleScheduleType!

  """
  The sum of the payment adequacy contributions on the payment schedule that are
  expected to be taken before the debt repayment is complete.
  """
  totalDebtAmount: Int
}

enum PaymentsVendorChoices {
  SMARTDEBIT
  GOCARDLESS
  STRIPE
  WESTPAC
}

"""An enumeration."""
enum PaymentType {
  DIRECT_DEBIT
  CARD
}

type PerformBoostCharge {
  upsideDevice: UpsideDeviceType @deprecated(reason: "upsideDevice is deprecated. Use krakenflexDevice instead.")
  krakenflexDevice: KrakenFlexDeviceType
}

type PerformMoveOut {
  account: AccountInterface
}

type PerformTestCharge {
  upsideDevice: UpsideDeviceType @deprecated(reason: "upsideDevice is deprecated. Use krakenflexDevice instead.")
  krakenflexDevice: KrakenFlexDeviceType
}

input PositionInput {
  latitude: Float
  longitude: Float
}

type PreKrakenBillType implements BillInterface {
  id: ID
  billType: BillTypeEnum
  fromDate: Date
  toDate: Date

  """
  Requesting this field generates a temporary URL at which bill is available.
          This URL will expire after approximately an hour.  It is intended for redirection purposes,
          NOT persistence in any form (e.g. inclusion in emails or the body of a web page).
          This field can raise an error with errorClass NOT_FOUND if the bill document has not
          been created/issued yet.
  
  
          Expected `errorClass`:
  - NOT_FOUND
  - SERVICE_AVAILABILITY
  """
  temporaryUrl: String

  """The date the bill was sent to the customer."""
  issuedDate: Date
}

"""

    The type of premise in which the CHF is located.
    
"""
enum PremiseType {
  """Detached / Semi-detached."""
  DETACHED_OR_SEMI

  """Terraced."""
  TERRACED

  """An apartment block with 5 floors or less."""
  LOW_RISE_APARTMENT

  """An apartment block with more than 5 floors."""
  HIGH_RISE_APARTMENT
}

type PrepayCreditTransferType {
  id: ID!
  netAmount: Int!
  createdDate: Date!
  smartPrepayStatus: SmartPrepayPaymentStatusChoices
  utrn: String
}

"""
The ledgers associated to a prepayment meter. There are three types: a credit
ledger for mirroring the meter's credit balance, a debt ledger for mirroring the
meter's debt balance and payment ledger which is the inflight payments that we
have not yet managed to resolve on the other two ledgers.
"""
type PrepayLedgersType {
  creditLedger: SupplementaryLedgerType
  debtLedger: SupplementaryLedgerType
  paymentLedger: PrepayPaymentLedgerType
}

"""
The in-flight payment ledger tracks the status of payments made to a prepay meter.
"""
type PrepayPaymentLedgerType implements SupplementaryLedgerInterface {
  id: ID

  """The display name of the ledger."""
  name: String
  ledgerType: String

  """The current final balance of the ledger in pence."""
  currentBalance: Int

  """Payments made to add credit to a smart prepay meter."""
  payments: [PrepayPaymentType]

  """Transfers of credit from the account ledger to a smart prepay meter."""
  creditTransfers: [PrepayCreditTransferType]
}

type PrepayPaymentType {
  id: ID!

  """Amount of payment in pence"""
  amount: Int!

  """The date this payment is scheduled to be debited"""
  paymentDate: Date!
  smartPrepayStatus: SmartPrepayPaymentStatusChoices
  utrn: String!
}

type PrepayTariff implements TariffType {
  id: ID
  displayName: String
  fullName: String
  description: String
  productCode: String
  standingCharge: Float
  preVatStandingCharge: Float
  unitRate: Float
  preVatUnitRate: Float
}

"""
A pre-signed, expiring and opaque tokens that can be swapped for a limited scope JWT (Kraken Token).
"""
type PreSignedToken {
  key: String!

  """The scope that the token will grant to the account user."""
  scope: ExpiringTokenScope!
  isValid: Boolean
}

"""

    Choices class for the pre-signed expiring tokens.

    These choices must have a certain format:

    {ACTION-VERB}_{DEFINING-NOUN}

    They should start with an action verb. It should be a single word.
    The action verb enables the account user to do the thing (defining noun)
    that comes after the action verb. Together they represent a task.

    The defining noun could be longer than a single word.
    Preferably, it should be kept short and simple as much as possible.
    
"""
enum PreSignedTokenScope {
  """Scope that enables account user to submit meter readings."""
  SUBMIT_METER_READINGS

  """Scope that enables account user to submit customer feedback."""
  SUBMIT_CUSTOMER_FEEDBACK

  """Scope that enables account user to book smart meter appointments."""
  BOOK_SMART_METER_APPOINTMENTS
}

type ProductTariffInformationLabelEco7 {
  supplier: String!
  tariffFullName: String!
  tariffDisplayName: String!
  tariffType: String!
  tariffCode: String!
  tariffEndsOn: String!
  paymentMethod: PaymentMethodChoices!
  priceGuaranteedUntil: String!
  exitFees: Int
  additionals: String
  tariffComparisonRate: Decimal
  estimatedAnnualCost: Int
  annualStandingCharge: Decimal!
  standingCharge: Decimal!
  unitRateDay: Decimal!
  unitRateNight: Decimal!
  assumedAnnualConsumptionDay: Int!
  assumedAnnualConsumptionNight: Int!

  """
  Some tariffs expect customers to alter their usage patterns (e.g. EV tariffs)
  so will redistribute total consumption accordingly.
  """
  consumptionDistributionCoefficients: ConsumptionDistributionCoefficients
}

type ProductTariffInformationLabelStandard {
  supplier: String!
  tariffFullName: String!
  tariffDisplayName: String!
  tariffType: String!
  tariffCode: String!
  tariffEndsOn: String!
  paymentMethod: PaymentMethodChoices!
  priceGuaranteedUntil: String!
  exitFees: Int
  additionals: String
  tariffComparisonRate: Decimal
  estimatedAnnualCost: Int
  annualStandingCharge: Decimal!
  standingCharge: Decimal!
  unitRate: Decimal!
  assumedAnnualConsumption: Int!
}

type ProductTariffInformationThreeRate {
  supplier: String!
  tariffFullName: String!
  tariffDisplayName: String!
  tariffType: String!
  tariffCode: String!
  tariffEndsOn: String!
  paymentMethod: PaymentMethodChoices!
  priceGuaranteedUntil: String!
  exitFees: Int
  additionals: String
  tariffComparisonRate: Decimal
  estimatedAnnualCost: Int
  annualStandingCharge: Decimal!
  standingCharge: Decimal!
  unitRateDay: Decimal!
  unitRateNight: Decimal!
  unitRateOffPeak: Decimal!
  assumedAnnualConsumptionDay: Int!
  assumedAnnualConsumptionNight: Int!
  assumedAnnualConsumptionOffPeak: Int!
}

type PropertyAddressType {
  addressLine1: String!
  addressLine2: String!
  town: String!
  county: String!
  country: String!
  postcode: String!
}

"""
This datatype declares what eligibility data which will be returned from
the query made to the datalake.
"""
type PropertyEligibilityDataType {
  fullAddress: String
  thoroughfare: String
  buildingNumber: String
  buildingName: String
  subBuildingName: String
  region: String
  postcode: String
  propertyType: String
  propertyStyle: String
  propertyCategoryReduced: String
  propertyCategoryDetailed: String
  isFlat: Boolean
  propertyValue: Float
  floorArea: Int
  yearBuiltCategory: String
  wallsDescription: String
  windowsDescription: String
  roofDescription: String
  numberOfBathrooms: Int
  numberOfBedrooms: Int
  meetsRoofInsulationCriteria: Boolean
  meetsWindowInsulationCriteria: Boolean
  meetsWallInsulationCriteria: Boolean
  isSupergreenReady: Boolean
  isAlmostSupergreenReady: Boolean
  noCurrentSolutionButWorkingOnIt: Boolean
  supergreenBoilerIsNotAGoodFit: Boolean
  hasOePropertyId: Boolean
  yearBuiltCast: Date
  coordinates: CoordinatesType
}

interface PropertyInterface {
  id: String

  """The address of the property, formatted into a single string"""
  address: String

  """List of address lines."""
  splitAddress: [String]

  """
  Time periods during which the property is associated with an account. Useful
  to display information about house-moves, as performing a move out of a
  property will set the end date for the occupancy period.
  """
  occupancyPeriods: [OccupancyPeriodType]

  """
  Coordinates for the property, useful for displaying the property on a map.
  """
  coordinates: CoordinatesType
}

"""
Represents a property. Conceptually, it collects supply points under an address.
"""
type PropertyType implements PropertyInterface {
  id: String
  postcode: String!

  """The address of the property, formatted into a single string"""
  address: String

  """List of address lines."""
  splitAddress: [String]

  """
  Time periods during which the property is associated with an account. Useful
  to display information about house-moves, as performing a move out of a
  property will set the end date for the occupancy period.
  """
  occupancyPeriods: [OccupancyPeriodType]

  """
  Coordinates for the property, useful for displaying the property on a map.
  """
  coordinates: CoordinatesType

  """Retrieve any smartmeter devices connected to the property."""
  smartDeviceNetworks: [SmartMeterDeviceNetworkType]

  """Retrieve the details of an electricity meter-point."""
  electricityMeterPoints: [ElectricityMeterPointType]

  """Retrieve the details of a gas meter-point."""
  gasMeterPoints: [GasMeterPointType]

  """
  Likelihood that a smart meter at the given postcode will get a stable network connection.
  """
  wanCoverage: WANCoverageStrengths

  """
  Timeslots for which the property has the possibility to book a smart-meter installation.
  """
  availableSmets2InstallationTimeslots: [Smets2InstallationTimeslotType]

  """Indicates if the property meets smart meter install preconditions."""
  isSmets2InstallationAllowed: Boolean
}

type ProvisionalTransactionConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ProvisionalTransactionConnectionTypeEdge]!
}

"""
A Relay edge containing a `ProvisionalTransactionConnectionType` and its cursor.
"""
type ProvisionalTransactionConnectionTypeEdge {
  """The item at the end of the edge"""
  node: ProvisionalTransactionType

  """A cursor for use in pagination"""
  cursor: String!
}

"""
A provisional transaction represents some debit or credit to or from a
customer's account which we cannot yet finalise for some reason, but which is
still useful to keep a note of, and display to the customer. Provisional
transactions are purely to give guidance in the absence of finalised
information. We therefore only return provisional transactions that have not
been finalised. When a transaction is finalised, it is available through the
`transactions` field.
"""
type ProvisionalTransactionType {
  id: ID!

  """
  A user readable string that indicates what this transaction relates to.
  """
  title: String

  """
  The amount in pence for this provisional transaction. It will be negative for charges, positive for credits.
  """
  amount: Int

  """The date at which the charge should be applied to the account."""
  date: Date
}

"""Represents a pairing of a single app installation to an account user."""
type PushNotificationBindingType {
  id: ID!
  messages: [EmailType!]!
  user: AccountUserType!
  token: String!
  application: NotifiableApplicationType!
  registeredAt: DateTime!
  expiresAt: DateTime!
}

"""An enumeration."""
enum QualifyingComponentOptions {
  """In receipt of Personal Independence Payments (PIP)"""
  PERSONAL_INDEPENDENCE_PAYMENTS

  """
  In receipt of Disability Living Allowance (DLA), any disability premium (all
  rates) or disabled child element of Universal Credit
  """
  DISABILITY_BENEFITS

  """
  In receipt of any Income-related benefit which includes: Carer’s Premium and
  Carer’s Allowance (for someone within the household) OR Attendance Allowance
  (for applicant or their partner) OR Industrial Injuries Benefit
  """
  INCOME_RELATED_BENEFITS

  """Hold a Maternity Exemption Certificate (MATEX)"""
  MATERNITY_EXEMPTION_CERTIFICATE

  """Hold a Medical Exemption Certificate (MEDEX)"""
  MEDICAL_EXEMPTION_CERTIFICATE

  """
  Are exempt from prescription charges (only for customers in England) or hold a HC2 certificate
  """
  PRESCRIPTION_CHARGES_EXEMPTION

  """
  Hold a valid war pension NHS exemption certificate and the prescription is for your disability
  """
  WAR_PENSION_EXEMPTION_CERTIFICATE

  """Old Age Threshold"""
  OLD_AGE_THRESHOLD

  """Are disabled or someone else within the household has a disability"""
  HAS_DISABILITY

  """
  Have a dependent child under 5 (dependent child who normally resides with the applicant)
  """
  DEPENDENT_CHILD_UNDER_FIVE

  """
  Have a dependent child aged 5 – 16 (dependent child who normally resides with
  the applicant), or under 18 if in full time education (dependent child who
  normally resides with the applicant)
  """
  DEPENDENT_CHILD_OVER_FIVE

  """
  In receipt of the limited capability for work element of Universal Credit
  """
  LIMITED_CAPABILITY_FOR_WORK
}

"""An enumeration."""
enum QualifyingCriteriaOptions {
  """Pension Credit"""
  PENSION_CREDIT

  """
  In receipt of Council Tax Reduction (excludes the 25% single person’s discount)
  """
  COUNCIL_TAX_REDUCTION

  """In receipt of Income Support"""
  INCOME_SUPPORT

  """
  In receipt of Income-based or Contribution-based Job Seeker’s Allowance (JSA)
  """
  JOB_SEEKERS_ALLOWANCE

  """
  In receipt of Income-related or Contribution-based Employment & Support Allowance (ESA)
  """
  EMPLOYMENT_AND_SUPPORT_ALLOWANCE

  """
  In receipt of Working Tax Credit with a total annual household income of
  £16,190 or less (before tax and National Insurance)
  """
  WORKING_TAX_CREDIT

  """
  In receipt of Housing Benefit with a total annual household income of £16,190 or less (before tax and National Insurance)
  """
  HOUSING_BENEFIT

  """
  In receipt of Child Tax Credit where the award statement shows a total annual
  household income of £16,190 or less (before tax and National Insurance)
  """
  CHILD_TAX_CREDIT

  """
  In receipt of universal credit, and has an earned income of between zero and
  £1,349 in at least one of the twelve preceding assessment periods
  """
  UNIVERSAL_CREDIT

  """
  A total annual household income of £16,190 or less (before tax and National Insurance)
  """
  LOW_INCOME_THRESHOLD
}

"""
Queries are the GraphQL equivalent of GET requests in REST. By convention, they
do not mutate data. To learn about how to form Queries in graphql, see
[GraphQL's documentation](https://graphql.org/learn/queries/).

⬅️ This interface will autocomplete, so just try typing what you want. You can
also search these docs. Some queries will require authentication. Check the
documentation or search `Authentication` for details.
"""
type Query {
  """This is a work in progress and not in use yet."""
  quoteRequest(
    """Kraken account number."""
    accountNumber: String!

    """Code of the quote request."""
    quoteCode: String!
  ): QuoteRequest

  """Follow on product."""
  followOnProduct(
    """Kraken account number."""
    accountNumber: String!

    """Electricity agreement Kraken ID."""
    electricityAgreementId: ID

    """Gas agreement Kraken ID."""
    gasAgreementId: ID
    validAt: DateTime!
  ): FollowOnProductType

  """Available energy product with the given display name."""
  availableProductFromDisplayName(
    """Display name of product"""
    displayName: String!
  ): EnergyProductType

  """
  Get details about FIT installations attached to an account, including any meters and previous readings.
  """
  fitInstallations(accountNumber: String!): [InstallationType]
  electricityPrepayLedgers(accountNumber: String!, mpan: String!, serialNumber: String!): PrepayLedgersType
  gasPrepayLedgers(accountNumber: String!, mprn: String!, serialNumber: String!): PrepayLedgersType

  """
   Get an electricity agreement. 
  
   
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  electricityAgreement(id: ID!): AgreementInterface

  """
   Get an gas agreement. 
  
   
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  gasAgreement(id: ID!): AgreementInterface

  """Validates a bank account"""
  validateBankAccount(accountNumber: String!, sortCode: String!, vendor: PaymentsVendorChoices): ValidateBankAccount

  """
  Get the default payment instruction for the account's Electric Juice Network ledger.
  """
  defaultElectricJuicePaymentInstruction(
    """The account number."""
    accountNumber: String!
  ): DefaultElectricJuicePaymentInstructionType

  """The annual electricity consumption data for an MPAN."""
  annualElectricityConsumption(
    """The MPAN of the meterpoint to return."""
    mpan: String!
  ): ElectricityConsumptionType!

  """The annual gas consumption data for an MPRN."""
  annualGasConsumption(
    """The MPRN of the meterpoint to return."""
    mprn: String!
  ): GasConsumptionType!

  """The validity of a SEG installation via the MCS installation database."""
  segInstallation(
    """The MCS certificate number."""
    mcsCertificateNumber: String!
  ): SEGInstallationType!

  """Vehicle charging preference details."""
  vehicleChargingPreferences(accountNumber: String!): VehicleChargingPreferencesType

  """A device registered with KrakenFlex for a given account."""
  registeredKrakenflexDevice(accountNumber: String!): KrakenFlexDeviceType

  """All planned device dispatches."""
  plannedDispatches(accountNumber: String!): [UpsideDispatchType]

  """All completed device dispatches."""
  completedDispatches(accountNumber: String!): [UpsideDispatchType]

  """All charge point devices."""
  chargePointDevices: [ChargePointDevicesType]

  """All electric vehicle types and their details."""
  electricVehicles(
    """Only return vehicle types for the specified make."""
    make: String

    """
    Only return vehicle types supported by the specified provider, e.g. Tesla
    """
    provider: IntelligentOctopusProviderChoices
  ): [ElectricVehicleType]

  """The user specific generated OCPP details."""
  ocppDetails(accountNumber: String!): OCPPDetailsType

  """List URLs for an account."""
  accountUrls(accountNumber: String!): [AccountUrl] @deprecated(reason: "Please access the URLs through the support site.")

  """The history of field sales visits to a specific address."""
  fieldSalesVisits(
    """The postcode of the addresses to return."""
    postcode: String!
    before: String
    after: String
    first: Int
    last: Int
  ): FieldSalesVisitConnectionTypeConnection!

  """Heat pump quote with accompanying EPC data."""
  heatPumpQuote(id: String): HeatPumpQuoteType

  """Winter workout goal for an account."""
  winterWorkoutGoal(accountNumber: String): WinterWorkoutGoalType

  """Winter workout initial estimates for an account."""
  winterWorkoutInitialEstimates(accountNumber: String): WinterWorkoutInitialEstimatesType

  """Winter workout tips for an account."""
  winterWorkoutTips(accountNumber: String): WinterWorkoutTipsType

  """Winter workout initial estimates for an account."""
  winterWorkoutGoalTracking(accountNumber: String): WinterWorkoutGoalTrackingType

  """Get the active terms and conditions for a product."""
  termsAndConditionsForProduct(productCode: String!): TermsAndConditionsType

  """Return a signup referral reward scheme with the given code."""
  domesticSignupRewardScheme(code: String!): ReferralSchemeType

  """Return a referral reward scheme for the given account referral code."""
  domesticAccountReferralRewardScheme(code: String!): ReferralSchemeType

  """Get deposit agreements for a given account."""
  depositAgreements(accountNumber: String!): [DepositAgreementOutput]

  """Get the default payment instruction for the account's main ledger."""
  defaultPaymentInstruction(
    """The account number."""
    accountNumber: String!

    """Provide an option to get either a CARD or DIRECT_DEBIT instruction."""
    instructionType: PaymentType
  ): PaymentInstructionType
  smartMeterDataPreferences(accountNumber: String!): SmartMeterDataPreferencesType

  """Links (urls) for the affiliate organizations."""
  affiliateLinks(
    """Email address of the affiliate agent."""
    agentContactEmail: String!
  ): [AffiliateLinkType!]!

  """
   The currently authenticated third party. 
  
   
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  thirdPartyViewer: ThirdPartyOrganizationType

  """Get details about an account."""
  account(accountNumber: String!): AccountType

  """Get account status information given its number."""
  accountStatusSearchByNumber(
    """The account number to search for."""
    accountNumber: String!
  ): AccountWithStatusInfoType

  """Get siteworks booking information for an account given its number."""
  siteworksBookingAccountSearchByNumber(
    """The account number to search for."""
    accountNumber: String!
  ): SiteworksBookingAccountType

  """Get siteworks booking information for an account given an MPAN."""
  siteworksBookingAccountSearchByMpan(
    """The MPAN to search for."""
    mpan: String!
  ): SiteworksBookingAccountType

  """Get siteworks booking information for an account given an MPRN."""
  siteworksBookingAccountSearchByMprn(
    """The MPRN to search for."""
    mprn: String!
  ): SiteworksBookingAccountType

  """Get siteworks booking information for accounts at a given postcode."""
  siteworksBookingAccountSearchByPostcode(
    """The postcode to search for."""
    postcode: String!

    """Filter the accounts by status."""
    statuses: [AccountStatusChoices]
    before: String
    after: String
    first: Int
    last: Int
  ): SiteworksBookingAccountConnectionTypeConnection

  """Siteworks appointments for the provided postcode."""
  siteworksAppointments(
    postcode: String!

    """Filter the Siteworks appointments by status."""
    statuses: [SiteworksAppointmentStatus]!
    before: String
    after: String
    first: Int
    last: Int
  ): SiteworksAppointmentConnectionTypeConnection

  """Siteworks appointments for the provided postcode."""
  externalSiteworksAppointments(
    postcode: String!

    """Filter the Siteworks appointments by status."""
    statuses: [SiteworksAppointmentStatus]!
    before: String
    after: String
    first: Int
    last: Int
  ): SiteworksAppointmentConnectionTypeConnection

  """
  Likelihood that a smart meter at the given postcode will get a stable network connection.
  """
  wanCoverage(postcode: String!): WANCoverageStrengths

  """
  Detailed WAN coverage report for a given post code and optional address identifier
  """
  wanCoverageDetail(postcode: String!, addressIdentifier: String): [WanCoverageDetail]

  """
  Returns set of available siteworks appointment slots for the given property.
  """
  siteworksAppointmentSlots(propertyId: ID!): SiteworksAppointmentSlotsType

  """
   The currently authenticated user. 
  
   
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  viewer: AccountUserType

  """
  If a quote code and product id are supplied, this returns that quote.
  Otherwise it returns an empty quote. This is a convenient way to expose both
  existing quotes, as well as the OFGEM consumption profiles are creating a quote.
  """
  quote(code: String): QuoteType

  """
   Fetch electricity meter readings for a given account and meter 
  
   
  
  This field is a connection type. Connections are used to implement [cursor
  based pagination](https://graphql.org/learn/pagination/#pagination-and-edges).
  
   
  
   
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  electricityMeterReadings(accountNumber: String!, meterId: String!, eventTypes: [MeterReadingEventType], before: String, after: String, first: Int, last: Int): ElectricityMeterReadingConnectionTypeConnection

  """
   Fetch gas meter readings for a given account and meter 
  
   
  
  This field is a connection type. Connections are used to implement [cursor
  based pagination](https://graphql.org/learn/pagination/#pagination-and-edges).
  
   
  
   
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  gasMeterReadings(accountNumber: String!, meterId: String!, eventTypes: [MeterReadingEventType], before: String, after: String, first: Int, last: Int): GasMeterReadingConnectionTypeConnection

  """
  Looks up an occupier account based on postcode and last 4 digits of the account number
  """
  occupierAccount(postcode: String!, shortcode: String!): OccupierAccount

  """
   A property with the given ID. Usually associated with supply points. 
  
   
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  property(id: ID!): PropertyType

  """
  The properties attached to the given account.
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  properties(accountNumber: String!, active: Boolean): [PropertyType]
  addresses(postcode: String!, searchDomesticOnly: Boolean, useDes: Boolean, before: String, after: String, first: Int, last: Int): AddressConnectionTypeConnection
  multipleElectricityMeterPointsForAddress(address: AddressSearchType, searchDomesticOnly: Boolean, useDes: Boolean): ElectricityMeterPointForAddressType
  energyProduct(code: String!): EnergyProductType

  """
  Get all products for a given brand and postcode. The supplied postcode will
  ensure that there are tariffs available on the product for the GSP.
  """
  energyProducts(postcode: String!, brand: String!, availability: EnergyProductAvailability, filterBy: [EnergyProductFilters], before: String, after: String, first: Int, last: Int): EnergyProductConnectionTypeConnection

  """Metadata for a linked object."""
  metadata(linkedObjectType: LinkedObjectType, identifier: String!): [Metadata]

  """Metadata for a linked object with key."""
  metadataForKey(linkedObjectType: LinkedObjectType, identifier: String!, key: String!): Metadata

  """Get the customer feedback survey question."""
  question(formId: Int!): String

  """Get default raw score for a customer feedback form."""
  defaultRawScore(formId: Int!): Int

  """list of matching account references"""
  accountReference(value: String): [AccountReferenceType]

  """The ID of the object"""
  node(id: ID!): Node
}

type QuotedProductType {
  id: ID!
  name: String!
  description: String!
  product: EnergyProductType
  recommended: Boolean!

  """
  Estimated cost in pence of the product per month based on the quoted usage.
  """
  monthlyAmount: Int

  """
  Estimated cost in pence of the product over a year based on the quoted usage. 
  """
  annualAmount: Int

  """
  Estimated saving in pence vs the 'Big 6' of the product over a year based on the quoted usage.
  """
  annualSaving: Int
  elecTariffCode: String!
  gasTariffCode: String!

  """
  Electricity tariff information label (TIL) provides standardised information between suppliers about a tariff.
  """
  electricityTariffInformationLabel: TariffInformationLabelType

  """
  Gas tariff information label (TIL) provides standardised information between suppliers about a tariff.
  """
  gasTariffInformationLabel: TariffInformationLabelStandard

  """Whether or not this is a variable product."""
  isVariable: Boolean

  """A list of dates allowable to start supply of the quoted product."""
  allowedSupplyStartDates: [Date]

  """The amount of co2 saved per year when this product is chosen"""
  co2SavingInKg: Int

  """
  The number of trees it would take to offset the amount of co2 that is saved per year when this product is chosen
  """
  treesSaving: Int
  includesCarbonOffsetting: Boolean
}

"""An enumeration."""
enum QuoteMeterType {
  """No meter (for gas-only customers)"""
  NO_METER

  """Standard"""
  STANDARD

  """Economy 7"""
  ECONOMY7

  """Smart meter"""
  SMART

  """Smart Economy7"""
  SMART_ECONOMY7

  """Smart Flat Economy7"""
  SMART_FLAT_ECONOMY7

  """Flat Economy7"""
  FLAT_ECONOMY7

  """Three-rate"""
  THREE_RATE

  """Flat three-rate"""
  FLAT_THREE_RATE

  """Other"""
  OTHER
}

"""An enumeration."""
enum QuotePaymentMethod {
  """Direct Debit"""
  DIRECTDEBIT

  """Credit card"""
  CREDITCARD

  """Pay on receipt of bill"""
  ONRECEIPT

  """Prepayment"""
  PREPAYMENT
}

type QuoteRequest {
  """List of electricity supply points and their quoted products."""
  electricitySupplyPoints: [ElectricitySupplyPoint]

  """List of gas supply points and their quoted products."""
  gasSupplyPoints: [GasSupplyPoint]
  createdAt: DateTime
}

type QuoteType {
  code: String
  postcode: String!
  gspGroupId: String
  includesElectricity: Boolean!
  includesGas: Boolean!
  isBusiness: Boolean!
  meterType: QuoteMeterType!
  mpan: String!
  paymentMethod: QuotePaymentMethod!

  """In kWh"""
  elecAnnualConsumptionStandard: Int

  """In kWh"""
  elecAnnualConsumptionDay: Int

  """In kWh"""
  elecAnnualConsumptionNight: Int
  elecEstimate: Boolean!

  """In kWh"""
  gasAnnualConsumption: Int
  gasEstimate: Boolean!
  partnerProductId: Int
  latitude: Float
  longitude: Float
  consumptionEstimates: ConsumptionEstimates

  """
  A list of the products that have been quoted for the usage provided at the time the quote was created.
  """
  quotedProducts(id: String): [QuotedProductType]
  termsAndConditions: TermsAndConditionsType
}

"""An enumeration."""
enum RateTypeChoices {
  """Standard."""
  STANDARD

  """Economy7."""
  ECONOMY7

  """Three-rate."""
  THREE_RATE
}

input ReadingInputType {
  register: String
  reading: Int
}

"""Record the customer's acceptance of a deposit agreement."""
type RecordDepositAgreementAccepted {
  isRecorded: Boolean
}

type ReferralConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ReferralConnectionTypeEdge]!
}

"""A Relay edge containing a `ReferralConnectionType` and its cursor."""
type ReferralConnectionTypeEdge {
  """The item at the end of the edge"""
  node: ReferralType

  """A cursor for use in pagination"""
  cursor: String!
}

interface ReferralInterface {
  referredUserName: String
  paymentStatus: String
  paymentDate: Date
  referredUserJoinDate: DateTime
  code: String
}

"""
A referral scheme is a way for one account to earn a reward for referring
another. This is achieved by the referred account using a url (provided by the
referring account) to sign up.
"""
type ReferralSchemeType {
  """
  A fully qualified url give people to create accounts referred by this scheme.
  """
  referralUrl: String

  """A referral url for display purposes."""
  referralDisplayUrl: String

  """The reward amount received by the referrer."""
  referrerRewardAmount: Int

  """The reward amount received by the referred party."""
  referredRewardAmount: Int

  """The reward amount received by the referrer and the referee combined."""
  combinedRewardAmount: Int

  """
  Whether the current account is eligible to be referred under this scheme.
  """
  canBeReferred: Boolean

  """The unique code for the scheme."""
  code: String

  """The given name of the person making the referral."""
  referrerGivenName: String

  """The family name of the person making the referral."""
  referrerFamilyName: String
}

type ReferralSchemeTypes {
  domestic: ReferralSchemeType
  business: ReferralSchemeType
  friendsAndFamily: ReferralSchemeType @deprecated(reason: "Please use domestic instead.")
}

"""Details of an account referral"""
type ReferralType implements ReferralInterface {
  id: ID!
  referredUserName: String
  paymentStatus: String
  paymentDate: Date
  referredUserJoinDate: DateTime
  code: String
}

type Refresh {
  payload: GenericScalar!
  refreshExpiresIn: Int!
  token: String!
  refreshToken: String!
}

"""An opaque token that can be used to renew a Kraken Token."""
type RefreshToken {
  key: String!

  """The datetime when the token will expire."""
  expiryDt: DateTime!
  isValid: Boolean
}

"""A refund to the customer from the energy supplier."""
type Refund implements TransactionType {
  id: ID
  postedDate: Date

  """Gross amount including tax whenever tax is payable."""
  amount: Int

  """
  The customer's resulting balance in pence after this transaction has been applied.
  """
  balanceCarriedForward: Int

  """Deprecated"""
  isCredit: Boolean

  """Deprecated"""
  isAccountCharge: Boolean

  """Deprecated"""
  isAccountPayment: Boolean

  """
  Whether the statement this transaction is on has been held. A held statement
  is not sent to a customer automatically, but is instead marked for manual
  attention by operations staff.
  """
  isHeld: Boolean
  title: String
  statementId: ID
  isReversed: Boolean!
}

"""The input type for the refund request."""
input RefundRequestInput {
  """The account number."""
  accountNumber: String!

  """The requested refund amount."""
  requestedAmount: Int!
}

type RefundRequestType {
  """The requested refund amount which was submitted in the repayment."""
  requestedAmountToReturn: Int
}

"""
Register a device via intelligent octopus.

Currently this means an electric vehicle and charge point details.
"""
type RegisterDevice {
  krakenflexDevice: KrakenFlexDeviceType
}

input RegisterDeviceInput {
  """Account number."""
  accountNumber: String!

  """The unique vehicle ID of the electric vehicle."""
  vehicle: VehicleInput!

  """The make, model and power of the charger."""
  chargePoint: ChargePointInput!

  """The provider used to authenticate the device."""
  provider: IntelligentOctopusProviderChoices!
  teslaAuthentication: TeslaAuthenticationInput

  """The authentication details required given the chosen provider."""
  authentication: AuthenticationInput
}

type RegisterPushNotificationBinding {
  pushNotificationBinding: PushNotificationBindingType
}

input RegisterPushNotificationBindingInput {
  """Device push notification token."""
  token: String!

  """
  Register a push notification binding. A push notification binding connects an
  account user to a specific application running on a specific device through a
  'registration token' (Android) or 'device token' (iOS). Using this binding we
  can send push notifications to the account user's devices.
  """
  bundleId: String!
}

type RegisterReading {
  identifier: String
  name: String
  value: String
  digits: Int
  isQuarantined: Boolean
}

"""
A request sent to notify Kraken of a new device, which will be prenotified to the adapter.
"""
type RegisterSmartDevice {
  """The reference for the associated request in Kraken."""
  requestReference: String
}

"""This type is used by agent services to notify Kraken of a new device."""
input RegisterSmartDeviceInput {
  """The ID of the device to register."""
  deviceId: String!

  """MPID of the Meter Asset Provider for the device."""
  mapMpid: String!

  """Supplier associated with the device."""
  supplierMpid: String!

  """The 4-letter manufacturer code for the device."""
  deviceManufacturer: String!

  """Model of the device."""
  deviceModel: String!

  """Type of the device, e.g. ESME or GSME."""
  deviceType: String!

  """SMETS CHTS version number."""
  smetsChtsVersion: String

  """Installation code of the device."""
  installCode: String!

  """ESME variant for an ESME device."""
  esmeVariant: String

  """Serial number for ESME or GSME devices."""
  serialNumber: String

  """Firmware version number."""
  firmwareVersion: String
}

"""An enumeration."""
enum RejectionReason {
  """Already received Warm Home Discount this tax year from the core group"""
  HAS_CORE_GROUP_DISCOUNT

  """
  Customer could not provide sufficient evidence to support their application
  """
  INSUFFICIENT_EVIDENCE_PROVIDED

  """Applicant is no longer on supply or our customer"""
  NO_LONGER_ON_SUPPLY
}

input RemovedElectricityMeterInput {
  serialNumber: String!
  meterType: ElectricityMeterTypes
  registers: [RemovedElectricityMeterRegisterInput]!
  readAt: DateTime
  prepayData: RemovedMeterPrepayDataInput
}

input RemovedElectricityMeterPointInput {
  mpan: String
  meters: [RemovedElectricityMeterInput]
}

input RemovedElectricityMeterRegisterInput {
  """Identifier string/label for the register."""
  id: String!
  finalReading: Float!
}

input RemovedGasMeterInput {
  serialNumber: String!
  meterType: GasMeterTypes
  finalReading: Float!
  readAt: DateTime
  prepayData: RemovedMeterPrepayDataInput
}

input RemovedGasMeterPointInput {
  mprn: String
  meters: [RemovedGasMeterInput]
}

input RemovedMeterPrepayDataInput {
  """The credit balance of the meter in millipence."""
  balance: Int

  """The total of all debt left on the removed meter in millipence."""
  cumulativeDebtBalance: Int

  """Amount of emergency credit remaining on the meter in millipence."""
  emergencyCreditBalance: Int
}

"""Renew agreement for a given meter point."""
type RenewAgreementForMeterPoint {
  electricityAgreement: RestrictedElectricityAgreement
  gasAgreement: RestrictedGasAgreement
}

input RenewAgreementForMeterPointInput {
  """MPxN to renew the agreement for."""
  mpxn: String!

  """Tariff code for the new agreement."""
  tariffCode: String!

  """The start date of the new agreement (inclusive)."""
  validFromDate: Date!

  """The end date of the new agreement (exclusive)."""
  validToDate: Date

  """Bespoke rates overriding those of the associated tariff."""
  bespokeTariffRates: BespokeTariffRatesInput

  """Information on the commission that's associated with this agreement."""
  commission: CommissionInput
}

"""
Renew agreements for an account.

This mutation calls tariff renewal use-case both
for electricity and gas agreements.

This mutation renews agreements from midnight the day it is invoked in the case of flexible
tariffs and fixed tariffs ending in more than 90 days. For fixed tariffs that end in less
than 90 days, it creates follow on agreements that start when the fixed agreements end (or
minimum of when they end in the case of misaligned agreements).
"""
type RenewAgreements {
  account: AccountType
}

"""Renew agreements provided for an account."""
type RenewAgreementsForAccount {
  account: AccountType
}

input RenewAgreementsForAccountInput {
  """Account number"""
  accountNumber: String!

  """
  A list of electricity agreements and the code of the product they will be renewed to.
  """
  electricityAgreements: [AgreementRenewalProductInput]

  """
  A list of gas agreements and the code of the product they will be renewed to.
  """
  gasAgreements: [AgreementRenewalProductInput]
}

input RenewAgreementsInput {
  """Account number"""
  accountNumber: String!

  """
  The ID if the quoted product we wish to use to create new agreements. Part of
  the tariff renewal journey involves re-quoting to ensure this is available.
  """
  quotedProductId: ID!

  """The ID of the property that agreements should be renewed for."""
  propertyId: ID!

  """
  Where the account's current payment schedule has a debt repayment element, we
  let the user choose whether to continue making catch-up payments, or to repay
  the full debt in addition to their next payment.
  """
  makeFullDebtRepayment: Boolean!
}

type RenewalProductType {
  slug: String!
  product: EnergyProductType
}

type ReportRemovedMeterDetails {
  result: ReportRemovedMeterDetailsOutput
}

input ReportRemovedMeterDetailsInput {
  """
  The installer/agents own booking reference for the appointment to remove these meters.
  """
  appointmentId: String
  electricityMeterPoint: RemovedElectricityMeterPointInput
  gasMeterPoint: RemovedGasMeterPointInput
}

type ReportRemovedMeterDetailsOutput {
  appointment: SiteworksAppointmentType
  electricityMeterPoint: SiteworksBookingElectricityMeterPointType
  gasMeterPoint: SiteworksBookingGasMeterPointType
}

input RequestResetPasswordMutationInput {
  email: String!
  isCreateMode: Boolean
  clientMutationId: String
}

type RequestResetPasswordMutationPayload {
  email: String!
  isCreateMode: Boolean
  errors: [ErrorType]
  clientMutationId: String
}

type Requote {
  quote: QuoteType
}

input RequoteInput {
  accountNumber: String!
  propertyId: ID!
  productAvailableAt: DateTime
}

input ResetPasswordMutationInput {
  password: String!
  userId: String!
  token: String!
  clientMutationId: String
}

type ResetPasswordMutationPayload {
  errors: [SerializerFieldErrorsType]
  clientMutationId: String
}

type RestrictedElectricityAgreement implements Node {
  validFrom: DateTime!
  validTo: DateTime

  """The ID of the object."""
  id: ID!
  tariffCode: String
}

type RestrictedGasAgreement implements Node {
  validFrom: DateTime!
  validTo: DateTime

  """The ID of the object."""
  id: ID!
  tariffCode: String
}

"""
Resume control of a device after having been away from home.

This is so that the device can be charged again according to the set preferences.
"""
type ResumeDeviceControl {
  upsideDevice: UpsideDeviceType @deprecated(reason: "upsideDevice is deprecated. Use krakenflexDevice instead.")
  krakenflexDevice: KrakenFlexDeviceType
}

"""

**⚠️ This type is currently in preview. During this time, it
  may change without warning in backwards-incompatible
  ways.**

A postal address.

This data model is based on the structure used by Google's
[libaddressinput library](https://github.com/google/libaddressinput)&mdash;so
you can use it, or other libraries that use its data model
and reference data, to accept input.

All fields can be blank, except for ``country`` which must
always be supplied.

"""
type RichAddressType {
  """A personal name."""
  name: String

  """The name of a business or organisation."""
  organization: String

  """
  
  The 'street address' component.
  
  This value can (and often will) contain newline characters
  when appropriate.
  
  In some cases, data may appear in this field instead of the
  below fields; e.g. a UK post town name may appear here
  instead of in the `dependent_locality` field. This happens
  when data has been migrated from a legacy format, and that
  format had insufficient metadata to determine the
  appropriate field.
  
  If `structured_street_address` is also set, the value of
  this field will be a string generated from that value.
  
  """
  streetAddress: String

  """
  
  The 'street address' component, in a structured format.
  
  This field stores the same value as `street_address`, but
  with more detail; for instance, instead of `123 Example
  Street` it might be `{'street_number': '123',
  'street_name': 'Example', 'street_type': 'Street'}`. In
  many cases this will be blank; we only use this field for
  Krakens where we need to supply this level of granularity
  to some third-party service, like a bulk mail provider.
  
  The exact structure of this value depends on the country _of
  the address_, which is not necessarily the same as the
  country this Kraken is configured to serve. For addresses
  outside of the countries listed below, this field will be
  left blank.
  
  ## `AU`: Australia
  
  The following keys may be present; all are optional. All
  keys have string values, and their meaning is the same as
  their aseXML counterparts. (Note that, unlike aseXML, all
  keys are provided at the top level, rather than being
  nested.)
  
  - `flat_or_unit_type`
  - `flat_or_unit_number`
  - `floor_or_level_type`
  - `floor_or_level_number`
  - `building_or_property_name`
  - `location_descriptor`
  - `house_number_1`
  - `house_number_suffix_1`
  - `house_number_2`
  - `house_number_suffix_2`
  - `lot_number`
  - `street_name`
  - `street_type`
  - `street_suffix`
  - `postal_delivery_type`
  - `postal_delivery_number_prefix`
  - `postal_delivery_number_value`
  - `postal_delivery_number_suffix`
  
  """
  structuredStreetAddress: GenericScalar

  """
  
  UK dependent localities, or neighbourhoods or boroughs in
  some other locations.
  
  """
  dependentLocality: String

  """
  
  City or town portion of an address, e.g. US city, AU
  suburb/town, IT comune, UK post town.
  
  """
  locality: String

  """
  
  Top-level administrative subdivision, e.g. US state, AU
  state/territory, IT region, JP prefecture.
  
  ## `AU`: Australia
  
  This must be one of `NSW`, `VIC`, `QLD`, `TAS`, `ACT`, `SA`,
  `NT`, `WA`. For addresses not within these locations, use
  the value that Australia Post uses, e.g. `ACT` for the
  Jervis Bay Territory or `WA` for Christmas Island.
  
  """
  administrativeArea: String

  """
  
  Postal code (ZIP code in the US).
  
  """
  postalCode: String

  """
  
  Sorting code, e.g. FR CEDEX code. This field is not used in many countries.
  
  """
  sortingCode: String

  """
  
  ISO 3166-1 alpha-2 code of the country this address belongs
  to, e.g. `AU`, `GB`.
  
  """
  country: String

  """
  
  Identifier used by the local postal service for this
  address, e.g. AU DPID, GB postcode + Delivery Point Suffix,
  US Zip-9 + Delivery Point.
  
  This is the value that gets encoded in the barcode printed
  on the envelope by large-volume bulk mail providers.
  
  """
  deliveryPointIdentifier: String
}

input RoomTemperatureInput {
  """Account number."""
  accountNumber: String!

  """
  The temperature the room should be set to. The valid temperature range is
  between 12 and 30 degrees in increments of 0.5 degrees.
  """
  temperature: Float!
}

type SEGInstallationType {
  """Whether the SEG installation is valid according to MCS."""
  isValid: Boolean!
}

type SerializerErrorType {
  message: String
  code: String
}

type SerializerFieldErrorsType {
  field: String
  errors: [ErrorTypeUnion!]
}

"""This mutation creates a winter workout goal for an account."""
type SetAccountWinterWorkoutGoal {
  winterWorkoutGoal: WinterWorkoutGoalType
}

input SetAccountWinterWorkoutGoalInput {
  accountNumber: String!

  """Input field for setting winter workout goal."""
  goal: WinterWorkoutGoalChoices!
}

"""This mutation creates a winter workout goal for an account."""
type SetAccountWinterWorkoutTips {
  winterWorkoutTips: WinterWorkoutTipsType
}

input SetAccountWinterWorkoutTipsInput {
  accountNumber: String!

  """Input field for setting winter workout tips."""
  tips: [WinterWorkoutTipInputType!]!
}

type SetClimateControlState {
  krakenflexDevice: KrakenFlexDeviceType
}

type SetHotWaterState {
  krakenflexDevice: KrakenFlexDeviceType
}

type SetRoomTemperature {
  krakenflexDevice: KrakenFlexDeviceType
}

"""Allow customers to set/update their vehicle's charging preferences."""
type SetVehicleChargingPreferences {
  upsideDevice: UpsideDeviceType @deprecated(reason: "upsideDevice is deprecated. Use krakenflexDevice instead.")
  krakenflexDevice: KrakenFlexDeviceType
}

"""An enumeration."""
enum SiteworksAppointmentAgent {
  """Smart Metering Systems"""
  SMS

  """AES Smart Metering"""
  AES

  """Octopus Energy Services"""
  OES

  """Providor Ltd"""
  PROVIDOR

  """Morrison Data Services"""
  MDS

  """E.on Metering"""
  EON_METERING

  """Lowri Beck Services Ltd"""
  LOWRI_BECK

  """MeterPlus"""
  METERPLUS

  """Enterprise Managed Services Ltd"""
  ENTERPRISE_MANAGED

  """Midlands Electricity plc"""
  MIDS_ELEC

  """Northern Powergrid"""
  N_POWERGRID

  """Electricity North West Limited"""
  ELEC_NW

  """National Grid"""
  NATIONAL_GRID
}

type SiteworksAppointmentConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [SiteworksAppointmentConnectionTypeEdge]!
}

"""
A Relay edge containing a `SiteworksAppointmentConnectionType` and its cursor.
"""
type SiteworksAppointmentConnectionTypeEdge {
  """The item at the end of the edge"""
  node: SiteworksAppointmentType

  """A cursor for use in pagination"""
  cursor: String!
}

type SiteworksAppointmentSlotsType {
  slots: [SiteworksAppointmentSlotType]
  expectedJobDurationMinutes: Int
}

type SiteworksAppointmentSlotType {
  appointmentDate: Date
  startTime: Time
  endTime: Time
}

"""An enumeration."""
enum SiteworksAppointmentStatus {
  """The Siteworks appointment that has been booked."""
  BOOKED

  """The Siteworks work that has been completed."""
  COMPLETED

  """The Siteworks appointment that has been aborted."""
  ABORTED

  """The Siteworks appointment that has been cancelled."""
  CANCELLED
}

type SiteworksAppointmentType {
  activeAppointment: ActiveAppointmentType
  account: AccountType
  property: PropertyType
}

type SiteworksBookingAccountConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [SiteworksBookingAccountConnectionTypeEdge]!
}

"""
A Relay edge containing a `SiteworksBookingAccountConnectionType` and its cursor.
"""
type SiteworksBookingAccountConnectionTypeEdge {
  """The item at the end of the edge"""
  node: SiteworksBookingAccountType

  """A cursor for use in pagination"""
  cursor: String!
}

"""
An object holding information about an account and its associated users,
properties and meter points, used for administering siteworks bookings.
"""
type SiteworksBookingAccountType {
  number: String!

  """The current status of the account."""
  status: AccountStatus
  users: [AccountUserType!]!
  billingName: String!
  accountType: String!

  """Properties linked to the account now and in the future."""
  properties: [SiteworksBookingPropertyType]

  """Siteworks requests associated to an account."""
  siteworksRequests: [SiteworksRequestType]
}

"""
This type holds information about an electricity meter point that is used by partner organisations to book siteworks.
"""
type SiteworksBookingElectricityMeterPointType implements SiteworksBookingMeterPointInterface {
  id: ID!
  supplyEndDate: Date
  mpan: String!

  """Standard settlement configuration"""
  ssc: String!
  energisationStatus: String!
  dccServiceFlag: String!
  status: String!
  isOnSupply: Boolean!

  """The latest supply period of the meterpoint."""
  latestSupplyPeriod: SupplyPeriodType

  """Whether this meter point has a meter which is due a reading."""
  isMeterReadingDue(maxReadingAge: Int): Boolean!
  meters(id: Int, includeInactive: Boolean): [ElectricityMeterType]

  """The distribution network the grid supply point falls under"""
  gspGroupId: String

  """A list of agents responsible for management of the meterpoint."""
  agentContracts(
    """Filter the contracts by status."""
    statuses: [AgentContractStatusType]
  ): [ElectricityAgentContractType]
}

"""
This type holds information about a gas meter point that is used by partner organisations to book siteworks.
"""
type SiteworksBookingGasMeterPointType implements SiteworksBookingMeterPointInterface {
  id: ID!
  supplyEndDate: Date
  mprn: String
  status: String!
  isOnSupply: Boolean!

  """The latest supply period of the meterpoint."""
  latestSupplyPeriod: SupplyPeriodType

  """Whether this meter point has a meter which is due a reading."""
  isMeterReadingDue(maxReadingAge: Int): Boolean!
  meters(id: Int, includeInactive: Boolean): [GasMeterType]

  """A list of agents responsible for management of the meterpoint."""
  agentContracts(
    """Filter the contracts by status."""
    statuses: [AgentContractStatusType]
  ): [GasAgentContractType]
}

"""Interface for common fields for SiteworksBookingMeterpoints."""
interface SiteworksBookingMeterPointInterface {
  status: String!
  isOnSupply: Boolean!

  """The latest supply period of the meterpoint."""
  latestSupplyPeriod: SupplyPeriodType

  """Whether this meter point has a meter which is due a reading."""
  isMeterReadingDue(maxReadingAge: Int): Boolean!
}

"""
This type is used by partner organisations to retrieve information about a
property and its meter points that is used to book siteworks.
"""
type SiteworksBookingPropertyType {
  id: ID!
  postcode: String!

  """Retrieve any smartmeter devices connected to the property."""
  smartDeviceNetworks: [SmartMeterDeviceNetworkType]

  """Retrieve the details of an electricity meter-point."""
  electricityMeterPoints: [SiteworksBookingElectricityMeterPointType]

  """Retrieve the details of a gas meter-point."""
  gasMeterPoints: [SiteworksBookingGasMeterPointType]

  """List of address lines."""
  splitAddress: [String]
}

"""

    Please note: these labels are exposed in the API documentation.
    
"""
enum SiteworksEventType {
  """SMICOP compliance report submitted"""
  SMICOP_COMPLIANCE_REPORT_SUBMITTED
}

type SiteworksRequestType {
  """Siteworks appointments associated to a request."""
  appointments: [ActiveAppointmentType]
}

type SmartMeterDataPreferencesType {
  """The reading frequency for the smart meter."""
  readingFrequency: SmartMeterReadingFrequencyChoices

  """
  Has the user given consent that their readings can be used for further analysis?
  """
  readingsAnalysisConsentProvided: Boolean

  """
  The datetime when the user gave consent that their readings can be used for further analysis.
  """
  readingsAnalysisConsentUpdatedDatetime: DateTime
}

"""
This is the network through which a set of SMETS2 devices communicates.
"""
type SmartMeterDeviceNetworkType {
  id: ID!

  """A list of devices attached to one network."""
  smartDevices(
    """Filter the devices by status."""
    statuses: [DeviceStatuses]
  ): [SmartMeterDeviceType]
}

"""A smart meter device."""
type SmartMeterDeviceType {
  id: ID!
  importElectricityMeter: ElectricityMeterType
  exportElectricityMeter: ElectricityMeterType
  gasMeter: GasMeterType
  deviceNetwork: SmartMeterDeviceNetworkType
  serialNumber: String!
  deviceId: String!
  type: DeviceType
  status: DeviceStatus!
  manufacturer: String!
  model: String!
  firmwareVersion: String!

  """
  The payment mode (e.g. credit or prepayment) that the device is currently operating in.
  """
  paymentMode: PaymentMode
}

"""An enumeration."""
enum SmartMeterInterestChoices {
  """
  We have captured that this account is interested in a SMETS2 meter. This does not mean they've booked an appointment.
  """
  INTERESTED

  """
  We have captured that this account could be interested in a SMETS2 meter in
  the future, so it is appropriate to follow up with them.
  """
  NOT_AT_THE_MOMENT

  """
  We have captured that this account is not interested in a SMETS2 meter. We
  should use this to avoid advertising SMETS2 meters to them, or contacting them
  about installing a SMETS2 meter.
  """
  NOT_INTERESTED
}

"""

    Meter reading frequency choices for smart meters.

    Please note: these labels are exposed in the API documentation.
    
"""
enum SmartMeterReadingFrequencyChoices {
  """Daily"""
  DAILY

  """Monthly"""
  MONTHLY

  """Half hourly"""
  HALF_HOURLY
}

"""An enumeration."""
enum SmartOnboardingEventType {
  """Onboarding started."""
  STARTED

  """Onboarding completed."""
  COMPLETED

  """Onboarding cancelled."""
  CANCELLED

  """Note Added."""
  NOTE_ADDED

  """Email sent to book meter exchange."""
  METER_EXCHANGE_EMAIL_SENT

  """Meter exchange date agreed."""
  METER_EXCHANGE_BOOKED

  """Meter Installed."""
  METER_INSTALLED

  """Meter Readings Available."""
  METER_READINGS_AVAILABLE

  """Email sent to request terms acceptance."""
  TERMS_EMAIL_SENT

  """Customer accepted terms and conditions."""
  TERMS_ACCEPTED

  """Agreements Updated."""
  AGREEMENTS_UPDATED

  """Email sent to confirm tariff switch."""
  TARIFF_SWITCH_CONFIRMATION_EMAIL_SENT

  """Tariff Changed On Meter."""
  TARIFF_CHANGED_ON_METER

  """Unable To Proceed."""
  UNABLE_TO_PROCEED

  """Previous Agreement Billing Gap Filled."""
  PREVIOUS_AGREEMENT_BILLING_GAP_FILLED

  """Email to install Intelligent Octopus app installed."""
  INTELLIGENT_OCTOPUS_INSTALL_APP_EMAIL_SENT

  """Test dispatch in app complete."""
  INTELLIGENT_OCTOPUS_TEST_DISPATCH_COMPLETE

  """Documents Checked."""
  DOCUMENTS_CHECKED

  """FIT resolution."""
  FIT_RESOLUTION

  """Export MPAN applied for."""
  EXPORT_MPAN_APPLIED_FOR

  """Export MPAN created."""
  EXPORT_MPAN_CREATED

  """MTDs updated."""
  MTD_UPDATED

  """Export Enabled In Kraken."""
  EXPORT_ENABLED_IN_KRAKEN

  """Export Meter Reading Available."""
  EXPORT_METER_READING_AVAILABLE

  """Export MPAN is on supply."""
  EXPORT_MPAN_ON_SUPPLY

  """First Credit Applied."""
  FIRST_CREDIT_APPLIED
}

type SmartOnboardingProcessType {
  id: ID!
  account: AccountType!
  meterPoint: ElectricityMeterPointType
  product: EnergyProductType!
}

"""An enumeration."""
enum SmartOnboardingTariffCodes {
  """Octopus Energy's Agile Octopus tariff"""
  AGILE_OCTOPUS

  """Octopus Energy's Octopus Go tariff"""
  OCTOPUS_GO

  """Octopus Energy's Octopus Go Faster tariff"""
  OCTOPUS_GO_FASTER

  """Octopus Energy's Tesla Energy Plan import tariff"""
  TESLA_IMPORT

  """Octopus Energy's Intelligent Octopus tariff"""
  INTELLIGENT_OCTOPUS

  """Octopus Energy's Outgoing Fixed tariff"""
  OUTGOING_FIXED

  """Octopus Energy's Octopus Agile tariff"""
  OUTGOING_AGILE
}

"""An enumeration."""
enum SmartOnboardingTermsStatuses {
  """Customer acceptance of T&Cs required"""
  TERMS_ACCEPTANCE_REQUIRED

  """Awaiting customer acceptance of T&Cs"""
  TERMS_EMAIL_SENT

  """T&Cs accepted"""
  TERMS_ACCEPTED
}

"""This type is used by clients to top-up a smart prepay meter"""
input SmartPrepayMeterAmountInput {
  """Account number of customer."""
  accountNumber: String!

  """Electricity or gas meter device ID."""
  deviceId: String!

  """Amount of credit to add to the meter, in pence."""
  amount: Int!

  """The top-up will wait for this payment to clear before proceeding."""
  paymentIntentId: Int
}

enum SmartPrepayPaymentStatusChoices {
  UTRN_REQUESTED
  UTRN_RECEIVED
  ACCEPTED_BY_METER
  RESOLVED
}

"""
('The smart tariff onboarding process. Only relevant for Kraken instances that
support half hourly tariffs. Returns null if not applicable.',)
"""
type SmartTariffOnboardingType {
  id: ID!
  latestStatus: SmartOnboardingEventType
  latestTermsStatus: SmartOnboardingTermsStatuses
  smartTariffCode: SmartOnboardingTariffCodes
  lastUpdated: String
}

"""
A timeslot for which a property can make an appointment for installation of a smart-meter.
"""
type Smets2InstallationTimeslotType {
  appointmentDate: Date
  startTime: Time
  endTime: Time
}

"""An enumeration."""
enum SMETS2InterestReason {
  """Doesn't own own home."""
  SMETS2_INTEREST_REASON_DO_NOT_OWN_HOME

  """Sceptical of technology."""
  SMETS2_INTEREST_REASON_TECHNOLOGY_SCEPTICAL

  """Worried about security."""
  SMETS2_INTEREST_REASON_WORRIED_SECURITY

  """Worried about health & safety."""
  SMETS2_INTEREST_REASON_WORRIED_HEALTH_SAFETY

  """Negative publicity about smart meters."""
  SMETS2_INTEREST_REASON_NEGATIVE_PUBLICITY

  """Worried about energy usage cost increasing."""
  SMETS2_INTEREST_REASON_WORRIED_ABOUT_USAGE_COST

  """Already has or is about to have a smart meter installed."""
  SMETS2_INTEREST_REASON_ALREADY_HAS_SMART_METER

  """About to move house."""
  SMETS2_INTEREST_REASON_HOUSE_MOVE_IMMINENT

  """About to switch supplier."""
  SMETS2_INTEREST_REASON_SWITCH_IMMINENT

  """More information about smart meters required."""
  SMETS2_INTEREST_REASON_MORE_INFORMATION_REQUIRED

  """Is a landlord."""
  SMETS2_INTEREST_REASON_IS_LANDLORD

  """Cannot see benefit."""
  SMETS2_INTEREST_REASON_CANNOT_SEE_BENEFIT

  """Wants to wait until it's compulsory."""
  SMETS2_INTEREST_REASON_WAIT_UNTIL_IT_IS_COMPULSORY

  """Has vulnerability."""
  SMETS2_INTEREST_REASON_VULNERABILITY

  """Worried about smart meters."""
  SMETS2_INTEREST_REASON_WORRIED_ABOUT_SMART_METERS

  """Worried about installation."""
  SMETS2_INTEREST_REASON_WORRIED_ABOUT_INSTALLATION

  """Property rarely or never occupied."""
  SMETS2_INTEREST_REASON_PROPERTY_NOT_OCCUPIED

  """Cannot attend appointment."""
  SMETS2_INTEREST_REASON_CANNOT_ATTEND_APPOINTMENT
}

"""An enumeration."""
enum Songs {
  """No Song Preferred"""
  NO_SONG_PREFERRED

  """Silence: “4’33”” by John Cage"""
  SONG_hold_music_4_33_silence

  """Ambient: Weightless by Marconi Union"""
  SONG_hold_music_ambient_weightless

  """"Auf Wiederseh’n Sweetheart" by Vera Lynn"""
  SONG_1938

  """"I Believe" by Frankie Laine"""
  SONG_1939

  """"Secret Love" by Doris Day"""
  SONG_1940

  """"Rose Marie" by Slim Whitman"""
  SONG_1941

  """"I’ll Be Home" by Pat Boone"""
  SONG_1942

  """"Diana" by Paul Anka"""
  SONG_1943

  """"Jailhouse Rock" by Elvis Presley"""
  SONG_1944

  """"Living Doll" by Cliff Richard"""
  SONG_1945

  """"It’s Now or Never" by Elvis Presley"""
  SONG_1946

  """"Wooden Heart" by Elvis Presley"""
  SONG_1947

  """"I Remember You" by Frank Ifield"""
  SONG_1948

  """"She Loves You" by The Beatles"""
  SONG_1949

  """"Can’t Buy Me Love" by The Beatles"""
  SONG_1950

  """"Tears" by Ken Dodd"""
  SONG_1951

  """"Green, Green Grass of Home" by Tom Jones"""
  SONG_1952

  """"Release Me" by Engelbert Humperdinck"""
  SONG_1953

  """"Hey Jude" by The Beatles"""
  SONG_1954

  """"Sugar, Sugar" by The Archies"""
  SONG_1955

  """"The Wonder of You" by Elvis Presley"""
  SONG_1956

  """"My Sweet Lord" by George Harrison"""
  SONG_1957

  """"Amazing Grace" by The Royal Scots Dragoon Guards Band"""
  SONG_1958

  """"Tie a Yellow Ribbon Round the Ole Oak Tree" by Dawn"""
  SONG_1959

  """"Tiger Feet" by Mud"""
  SONG_1960

  """"Bye Bye Baby" by Bay City Rollers"""
  SONG_1961

  """"Save Your Kisses for Me" by Brotherhood of Man"""
  SONG_1962

  """"Mull of Kintyre" / "Girls’ School" by Wings"""
  SONG_1963

  """"Rivers of Babylon" / "Brown Girl in the Ring" by Boney M."""
  SONG_1964

  """"Bright Eyes" by Art Garfunkel"""
  SONG_1965

  """"Don’t Stand So Close to Me" by The Police"""
  SONG_1966

  """"Don’t You Want Me" by The Human League"""
  SONG_1967

  """"Come On Eileen" by Dexys Midnight Runners"""
  SONG_1968

  """"Karma Chameleon" by Culture Club"""
  SONG_1969

  """"I Just Called To Say I Love You" by Stevie Wonder"""
  SONG_1970

  """"The Power of Love" by Jennifer Rush"""
  SONG_1971

  """"Don’t Leave Me This Way" by The Communards"""
  SONG_1972

  """"Never Gonna Give You Up" by Rick Astley"""
  SONG_1973

  """"The Only Way Is Up" by Yazz"""
  SONG_1974

  """"Ride On Time" by Black Box"""
  SONG_1975

  """"Unchained Melody" by The Righteous Brothers"""
  SONG_1976

  """"Everything I Do I Do It for You" by Bryan Adams"""
  SONG_1977

  """"I Will Always Love You" by Whitney Houston"""
  SONG_1978

  """"I’d Do Anything for Love (But I Won’t Do That)" by Meat Loaf"""
  SONG_1979

  """"Love Is All Around" by Wet Wet Wet"""
  SONG_1980

  """"Unchained Melody" by Robson &amp; Jerome"""
  SONG_1981

  """"Killing Me Softly" by Fugees"""
  SONG_1982

  """
  "Candle in the Wind 1997" / "Something About the Way You Look Tonight" by Elton John
  """
  SONG_1983

  """"Believe" by Cher"""
  SONG_1984

  """"...Baby One More Time" by Britney Spears"""
  SONG_1985

  """"Pure Shores" by All Saints"""
  SONG_1986

  """"It Wasn’t Me" by Shaggy featuring Rikrok"""
  SONG_1987

  """"Anything Is Possible" / "Evergreen" by Will Young"""
  SONG_1988

  """"Where Is the Love?" by The Black Eyed Peas"""
  SONG_1989

  """"Call On Me" by Eric Prydz"""
  SONG_1990

  """"Is This the Way to Amarillo" by Tony Christie featuring Peter Kay"""
  SONG_1991

  """"Crazy" by Gnarls Barkley"""
  SONG_1992

  """"Bleeding Love" by Leona Lewis"""
  SONG_1993

  """"Hallelujah" by Alexandra Burke"""
  SONG_1994

  """"Poker Face" by Lady Gaga"""
  SONG_1995

  """"Just The Way You Are" by Bruno Mars"""
  SONG_1996

  """"Someone Like You" by Adele"""
  SONG_1997

  """"Somebody That I Used to Know" by Gotye featuring Kimbra"""
  SONG_1998

  """"Get Lucky" by Daft Punk"""
  SONG_1999

  """"Happy" by Pharrell Williams"""
  SONG_2000

  """"Uptown Funk" by Mark Ronson featuring Bruno Mars"""
  SONG_2001

  """"7 Years" by Lukas Graham"""
  SONG_2002

  """"Shape of You" by Ed Sheeran"""
  SONG_2003
}

"""
Any special circumstances that the user has notified us about, which may entitle them to some specialist services.
"""
type SpecialCircumstanceRecordType {
  id: ID
  summary: String
  internalCode: String
  gasPSRCode: String
  electricityPSRCode: String
}

union SpecialCircumstanceRecordUnion = SpecialCircumstanceRecordType | TemporarySpecialCircumstanceRecordType

"""Information about the special circumstances that relate to a user."""
type SpecialCircumstancesType {
  """
  Whether the user has consented for their data to be given to the appropriate
  industry or regulatory bodies. We typically only ask for this once, so this
  field can be used to decide whether to ask the user for their initial consent.
  """
  isSharingConsentGiven: Boolean
  records: [SpecialCircumstanceRecordUnion]
}

type StandardTariff implements TariffType {
  id: ID
  displayName: String
  fullName: String
  description: String
  productCode: String
  standingCharge: Float
  preVatStandingCharge: Float
  unitRate: Float
  preVatUnitRate: Float
}

"""
Onboarding for export tariffs.

This mutation kicks off the export onboarding for electricity.
"""
type StartExportOnboardingProcess {
  onboardingProcess: SmartOnboardingProcessType
}

input StartExportOnboardingProcessInput {
  """Account number."""
  accountNumber: String!

  """The import MPAN."""
  importMpan: String

  """The export MPAN."""
  exportMpan: String

  """The export product code."""
  productCode: String!

  """The export technology type."""
  technologyType: ExportTechnologyType!

  """The FiT ownership status."""
  fitStatus: FITStatus!

  """Whether to take over the FiT generation payments."""
  includeFitGeneration: Boolean = false

  """The FiT ID."""
  fitId: String

  """The MCS certificate number."""
  mcsCertNumber: String

  """The DNO status."""
  dnoStatus: DNOStatus!

  """
  Have the terms and conditions for this product been accepted? To be deprecated.
  """
  termsAndConditionsAccepted: Boolean!

  """Version of the terms and conditions that have been accepted."""
  acceptedTermsAndConditionsVersion: String
}

"""
Onboarding for smart tariffs.

This mutation kicks off the smart onboarding for electricity.
"""
type StartSmartOnboardingProcess {
  onboardingProcess: SmartOnboardingProcessType
}

input StartSmartOnboardingProcessInput {
  """Account number."""
  accountNumber: String!

  """The MPAN to switch."""
  mpan: String!

  """The product code to switch to."""
  productCode: String!
  isNewAccount: Boolean = false
  termsAndConditions: TermsAndConditions
}

"""An enumeration."""
enum StatementReversalsAfterClose {
  """All charges have been reversed after the statement was closed."""
  ALL

  """Some charges have been reversed after the statement was closed."""
  SOME

  """No reversals after the statement was closed."""
  NONE

  """The statement has not been closed yet."""
  NOT_CLOSED
}

type StatementType implements BillInterface {
  id: ID
  billType: BillTypeEnum
  fromDate: Date
  toDate: Date

  """
  Requesting this field generates a temporary URL at which bill is available.
          This URL will expire after approximately an hour.  It is intended for redirection purposes,
          NOT persistence in any form (e.g. inclusion in emails or the body of a web page).
          This field can raise an error with errorClass NOT_FOUND if the bill document has not
          been created/issued yet.
  
  
          Expected `errorClass`:
  - NOT_FOUND
  - SERVICE_AVAILABILITY
  """
  temporaryUrl: String

  """The date the bill was sent to the customer."""
  issuedDate: Date

  """This field returns the closing balance of an issued statement."""
  closingBalance: Int

  """Whether the bill originated in Kraken or externally."""
  isExternalBill: Boolean

  """Transactions on the bill."""
  transactions(before: String, after: String, first: Int, last: Int): TransactionConnectionTypeConnection

  """Email recipient user ID."""
  userId: Int

  """Email recipient address."""
  toAddress: String

  """The date the bill is due to be paid."""
  paymentDueDate: Date

  """The first day of consumption that this statement includes"""
  consumptionStartDate: Date

  """The last day of consumption that this statement includes"""
  consumptionEndDate: Date

  """How many charges have been reversed after the close date."""
  reversalsAfterClose: StatementReversalsAfterClose!
}

"""An enumeration."""
enum Status {
  """Pending"""
  PENDING

  """Awaiting audit"""
  AWAITING_AUDIT

  """Awaiting customer evidence"""
  AWAITING_CUSTOMER_EVIDENCE

  """Approved"""
  APPROVED

  """Rejected"""
  REJECTED

  """Withdrawn"""
  WITHDRAWN

  """Approved (customer service gesture)"""
  APPROVED_CUSTOMER_SERVICE_GESTURE
}

"""Store a new card instruction for Electric Juice from an embedded form."""
type StoreCardPaymentInstruction {
  paymentInstruction: PaymentInstructionType
}

"""The input for storing a new card instruction from an embedded form."""
input StoreCardPaymentInstructionInput {
  """The account number."""
  accountNumber: String!

  """The datetime from which the instruction is vaild."""
  validFrom: DateTime!

  """The vendor's reference for this payment method."""
  vendorReference: String!
}

"""Store a new card instruction for Electric Juice from an embedded form."""
type StoreElectricJuicePaymentInstruction {
  paymentInstruction: PaymentInstructionType
}

"""The input for storing a new card instruction from an embedded form."""
input StoreElectricJuicePaymentInstructionInput {
  """The account number."""
  accountNumber: String!

  """The datetime from which the instruction is vaild."""
  validFrom: DateTime!

  """The vendor's reference for this payment method."""
  vendorReference: String!
}

type SubmitCustomerFeedback {
  customerFeedback: CustomerFeedbackType
}

interface SupplementaryLedgerInterface {
  id: ID

  """The display name of the ledger."""
  name: String
  ledgerType: String

  """The current final balance of the ledger in pence."""
  currentBalance: Int
}

"""
Ledgers provide the foundation of Kraken’s bookkeeping functionality. Similar to
a bank account, they allow us to keep track of financial activity on a
particular Kraken account.
"""
type SupplementaryLedgerType implements SupplementaryLedgerInterface {
  id: ID

  """The display name of the ledger."""
  name: String
  ledgerType: String

  """The current final balance of the ledger in pence."""
  currentBalance: Int
}

type SupplyPeriodType {
  """The start date of the supply period."""
  supplyStartAt: DateTime

  """The end date of the supply period."""
  supplyEndAt: DateTime
}

"""
Suspend control of a device while away from home, e.g. on holiday.

This is to prevent charging during that period.
"""
type SuspendDeviceControl {
  upsideDevice: UpsideDeviceType @deprecated(reason: "upsideDevice is deprecated. Use krakenflexDevice instead.")
  krakenflexDevice: KrakenFlexDeviceType
}

type TariffInformationLabelEco7 {
  supplier: String
  tariffName: String
  tariffType: String
  tariffCode: String
  paymentMethod: String
  tariffEndsOn: String
  priceGuaranteedUntil: String
  exitFees: Int
  additionals: String
  tariffComparisonRate: Float
  standingCharge: Float
  estimatedAnnualCost: Int
  annualStandingCharge: Float
  unitRateDay: Float
  unitRateNight: Float
  assumedAnnualConsumptionDay: Int
  assumedAnnualConsumptionNight: Int
}

type TariffInformationLabelStandard {
  supplier: String
  tariffName: String
  tariffType: String
  tariffCode: String
  paymentMethod: String
  tariffEndsOn: String
  priceGuaranteedUntil: String
  exitFees: Int
  additionals: String
  tariffComparisonRate: Float
  standingCharge: Float
  estimatedAnnualCost: Int
  annualStandingCharge: Float
  unitRate: Float
  assumedAnnualConsumption: Int
}

union TariffInformationLabelType = TariffInformationLabelStandard | TariffInformationLabelEco7

interface TariffType {
  id: ID
  displayName: String
  fullName: String
  description: String
  productCode: String
  standingCharge: Float
  preVatStandingCharge: Float
}

"""
Any special circumstances that the user has notified us about, which may entitle
them to some specialist services. These circumstances have an end date, after
which they will not longer apply. Having young children is an example of this in the UK.
"""
type TemporarySpecialCircumstanceRecordType {
  id: ID
  summary: String
  internalCode: String
  gasPSRCode: String
  electricityPSRCode: String
  expiryDate: Date
}

input TermsAndConditions {
  """The version of the terms and conditions the user was presented with."""
  version: String!
  accepted: Boolean!
}

type TermsAndConditionsType {
  name: String
  pdfUrl: String
  brandCode: String

  """The markdown text of the terms and conditions."""
  markdown: String

  """
  The html of the terms and conditions document rendered as a JSON string.
  """
  html: String
  version: String
  effectiveFrom: DateTime
}

input TeslaAuthenticationInput {
  """SSO access token for Tesla authentication."""
  accessToken: String!

  """SSO refresh token for Tesla authentication."""
  refreshToken: String!

  """SSO token expiry for Tesla authentication (integer in seconds)."""
  expiresIn: Int!
}

"""Type for the third party organization."""
type ThirdPartyOrganizationType {
  name: String!
}

type ThreeRateTariff implements TariffType {
  id: ID
  displayName: String
  fullName: String
  description: String
  productCode: String
  standingCharge: Float
  preVatStandingCharge: Float
  dayRate: Float
  nightRate: Float
  offPeakRate: Float
  preVatDayRate: Float
  preVatNightRate: Float
  preVatOffPeakRate: Float
}

"""
The `Time` scalar type represents a Time value as
specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar Time

type TrackerTariffDailyPricing {
  """URL for tracker demo"""
  demoUrl: String

  """Today's electricity costs (in pence)"""
  electricity: Int

  """Today's gas costs (in pence)"""
  gas: Int
}

"""Key value pair for the choice of tracks."""
type TrackOptionType {
  """The title of the track."""
  trackTitle: String

  """The value save for the user to indicate their choice of track."""
  trackCode: String
}

type TransactionConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [TransactionConnectionTypeEdge]!
}

"""A Relay edge containing a `TransactionConnectionType` and its cursor."""
type TransactionConnectionTypeEdge {
  """The item at the end of the edge"""
  node: TransactionType

  """A cursor for use in pagination"""
  cursor: String!
}

"""
Transactions are a record of money being added or subtracted from the overall account balance
"""
interface TransactionType {
  id: ID
  postedDate: Date

  """Gross amount including tax whenever tax is payable."""
  amount: Int

  """
  The customer's resulting balance in pence after this transaction has been applied.
  """
  balanceCarriedForward: Int

  """Deprecated"""
  isCredit: Boolean

  """Deprecated"""
  isAccountCharge: Boolean

  """Deprecated"""
  isAccountPayment: Boolean

  """
  Whether the statement this transaction is on has been held. A held statement
  is not sent to a customer automatically, but is instead marked for manual
  attention by operations staff.
  """
  isHeld: Boolean
  title: String
  statementId: ID
  isReversed: Boolean!
}

"""

    Add here your filter type, e.g. MY_TYPE = "MY_TYPE". This type will come up as on option when applying a filter in
    the transactions() query in the GraphQL API.
    
"""
enum TransactionTypeFilter {
  """Return energy charge transactions: Gas or Electricity."""
  ENERGY_CHARGES
}

type TriggerPostUploadOperations {
  operationsTriggered: Boolean
}

type UnitRate {
  validFrom: DateTime
  validTo: DateTime

  """Price in pence (inc VAT)"""
  value: Float

  """Price in pence (not including VAT)"""
  preVatValue: Float
}

"""Update a reference for a particular account and namespace."""
type UpdateAccountReference {
  accountReference: AccountReferenceType
}

"""Set stated interest in acquiring a smart meter of an account."""
type UpdateAccountSmartMeterInterest {
  interestUpdated: Boolean

  """The interest of an account in procuring smart meters."""
  smets2Interest: SmartMeterInterestChoices

  """
  The reason why the account holder is not interested in having a smart meter installed.
  """
  smets2RefusalReason: SMETS2InterestReason
}

input UpdateAccountSmartMeterInterestInput {
  accountNumber: String!

  """Input field for setting smart meter interest."""
  smets2Interest: SmartMeterInterestChoices!

  """
  Input field for setting the reason for why a customer is not interested in a smart meter.
  """
  smets2RefusalReason: SMETS2InterestReason
}

input UpdateAccountUserCommsPreferencesMutationInput {
  isOptedInToClientMessages: Boolean
  isOptedInToOfferMessages: Boolean
  isOptedInToRecommendedMessages: Boolean
  isOptedInToUpdateMessages: Boolean
  isOptedInToThirdPartyMessages: Boolean
  isOptedInMeterReadingConfirmations: Boolean
  isOptedInToSmsMessages: Boolean
  isUsingInvertedEmailColours: Boolean
  fontSizeMultiplier: Float
  emailFormat: String
  preferredHoldMusic: String
  clientMutationId: String
}

"""Update the account user comms preferences."""
type UpdateAccountUserCommsPreferencesMutationPayload {
  isOptedInToClientMessages: Boolean
  isOptedInToOfferMessages: Boolean
  isOptedInToRecommendedMessages: Boolean
  isOptedInToUpdateMessages: Boolean
  isOptedInToThirdPartyMessages: Boolean
  isOptedInMeterReadingConfirmations: Boolean
  isOptedInToSmsMessages: Boolean
  isUsingInvertedEmailColours: Boolean
  fontSizeMultiplier: Float
  emailFormat: String
  preferredHoldMusic: String
  errors: [ErrorType]
  commsPreferences: AccountUserCommsPreferences
  clientMutationId: String
}

input UpdateAccountUserMutationInput {
  givenName: String
  familyName: String
  pronouns: String
  mobile: String
  email: String
  dateOfBirth: Date
  landline: String
  clientMutationId: String
}

type UpdateAccountUserMutationPayload {
  givenName: String
  familyName: String
  pronouns: String
  mobile: String
  email: String
  dateOfBirth: Date
  landline: String
  errors: [ErrorType]
  clientMutationId: String
}

"""Update an affiliate link of an existing sales agent."""
type UpdateAffiliateLink {
  affiliateLink: AffiliateLinkType
}

input UpdateAffiliateLinkInputType {
  """The id of the affiliate link that is going to be edited."""
  linkId: ID!

  """The organisation for whom to update the affiliate link for."""
  organisationId: ID

  """
  
  Will be validated as follows:
  
  - should be at least two characters
  - should only contain (letters, numbers, and Hyphen)
  - should not contain bad words
  - should not contain any of the reserved words including:
   kraken, www, tech, mail, click, business, webhooks, api, www2, sendgrid, friends, developer, consul, affiliates
  """
  subdomain: String
  contactName: String
  contactEmail: String
  isBusiness: Boolean
  landingUrl: String
  trainingStatus: String
}

"""
Update the comms delivery preference for the input account number to the
received commsDeliveryPreference value.
"""
type UpdateCommsDeliveryPreference {
  account: AccountInterface
}

"""Input fields for updating comms delivery preferences for an account"""
input UpdateCommsDeliveryPreferenceInput {
  accountNumber: String!
  commsDeliveryPreference: CommsDeliveryPreference!
}

"""Update the status of the communications hub."""
type UpdateCommsHubStatus {
  """The id of the Request object in Kraken."""
  requestReference: String
}

input UpdateCommsHubStatusInput {
  """Device ID of the CHF (Communications Hub Function)."""
  chfDeviceId: String!

  """The type of status update to be sent."""
  updateType: CommsHubStatusUpdateType!

  """MPAN of the meter point linked to the CHF."""
  mpan: String!

  """Is it a new or replacement CHF?"""
  chfInstallType: CHFInstallType

  """Was an external aerial installed?"""
  hasAerialInstalled: Boolean

  """Location of the CHF."""
  chfLocation: CHFLocation

  """Type of the premise in which the CHF is located."""
  premiseType: PremiseType

  """
  In the case of NO_SM_WAN, was the issue a local metal obstruction (as defined in CHSM)?
  """
  hasMetalObstruction: Boolean

  """
  In the case of NO_SM_WAN, was the issue a thick stone wall obstruction (as defined in CHSM)?
  """
  hasConnectivityObstruction: Boolean

  """
  In the case of NO_SM_WAN, was the CHF in a shared/communal area (as defined in CHSM)?
  """
  hasSharedObstruction: Boolean

  """The engineer's description of the fault."""
  faultReason: CHFFaultReason

  """Whether a fault was identified before or after the installation."""
  faultReturnType: CHFFaultReturnType

  """
  How the CHF was installed and connected to the rest of the Smart Metering System.
  """
  chfConnectionMethod: CHFConnectionMethod

  """
  In the case of NO_FAULT_RETURN, the reason for the meter not being installed.
  """
  noFaultReturnType: CHFNoFaultReturnType
}

"""Update existing metadata on an object."""
type UpdateMetadata {
  metadata: Metadata
}

type UpdatePassword {
  """
   The currently authenticated user. 
  
   
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  viewer: AccountUserType
}

input UpdatePasswordInput {
  """Old password"""
  oldPassword: String!

  """New password"""
  newPassword: String!

  """Confirm new password"""
  newPasswordConfirmed: String!
}

type UpdatePaymentSchedulePaymentAmount {
  paymentSchedule: PaymentScheduleType
}

input UpdatePaymentSchedulePaymentAmountInput {
  accountNumber: String!

  """Amount in pence"""
  amount: Int!
}

type UpdatePaymentSchedulePaymentDay {
  paymentSchedule: PaymentScheduleType
}

input UpdatePaymentSchedulePaymentDayInput {
  accountNumber: String!
  paymentDay: Int!
}

"""Update smart meter data preferences of an account."""
type UpdateSmartMeterDataPreferences {
  preferencesUpdated: Boolean
  smartMeterDataPreferences: SmartMeterDataPreferencesType
}

input UpdateSmartMeterDataPreferencesInput {
  accountNumber: String!

  """The desired reading frequency for the smart meter."""
  readingFrequency: SmartMeterReadingFrequencyChoices!

  """The consent that smart meter readings can be used for further analysis"""
  allowReadingsAnalysis: Boolean
}

type UpdateSpecialCircumstances {
  specialCircumstances: SpecialCircumstancesType
}

input UpdateSpecialCircumstancesInput {
  """Additional presence preferred"""
  additionalPresencePreferred: Boolean

  """Blind"""
  blind: Boolean

  """Careline/telecare system"""
  carelineTelecareSystem: Boolean

  """Chronic/serious illness"""
  chronicSeriousIllness: Boolean

  """Dementia"""
  dementia: Boolean

  """Developmental condition"""
  developmentalCondition: Boolean

  """Pensionable age"""
  elderly: Boolean
  hearingImpairment: Boolean

  """Heart, lung & ventilator"""
  heartLungMachine: Boolean

  """Dialysis, feeding pump and automated medication"""
  kidneyDialysis: Boolean

  """MDE electric showering"""
  mdeElectricShowering: Boolean

  """Medicine refrigeration"""
  medicineRefrigeration: Boolean

  """Mental health"""
  mentalHealth: Boolean

  """Nebuliser and apnoea monitor"""
  nebuliser: Boolean

  """Oxygen concentrator"""
  oxygenConcentrator: Boolean

  """Oxygen Use"""
  oxygenUse: Boolean
  partialSighted: Boolean
  physicalImpairment: Boolean
  poorSenseOfSmell: Boolean
  restrictedHandMovement: Boolean
  restrictedMovement: Boolean
  speechImpairment: Boolean
  stairLift: Boolean
  waterDependent: Boolean
  familiesWithYoungChildren5OrUnder: Boolean
  familiesWithYoungChildren5OrUnderEndDate: String
  temporaryLifeChanges: Boolean
  temporaryLifeChangesEndDate: String
  temporaryPostHospitalRecovery: Boolean
  temporaryPostHospitalRecoveryEndDate: String
  temporaryYoungAdultHouseholder: Boolean
  temporaryYoungAdultHouseholderEndDate: String
  foreignLanguageSpeaker: Boolean

  """Preferred language"""
  language: String

  """Use a unique password to identify our staff and partners"""
  usePasswordToIdentify: Boolean
  partnerPassword: String

  """
  Consent required to allow priority service request information to be shared. You will only need to provide this once
  """
  userConsent: Boolean
}

input UpdateUserInput {
  givenName: String
  familyName: String

  """
  How the user would like us to address them (e.g. 'she/her', 'they/them').
  Because this field is clearable, null and the empty string are treated
  differently; passing null or omitting the field leaves the value as-is, but
  explicitly passing an empty string clears this value.
  """
  pronouns: String
  email: String
  mobile: String
  dateOfBirth: Date
  landline: String

  """
  The user for whom to perform the update. This is only needed when using an Organisation role
  """
  userId: String
}

type UpdateUserMutation {
  viewer: AccountUserType
}

"""
Information that should be used in the POST request to the S3 API.

For more details please see [this](https://boto3.amazonaws.com/v1/documentation/api/latest/guide/s3-presigned-urls.html#generating-a-presigned-url-to-upload-a-file).
"""
type UploadPostRequest {
  url: String!
  fields: JSONString!
  key: String!
}

type UpsideDeviceType {
  upsideDeviceId: String
  vehicleMake: String
  vehicleModel: String
  chargePointMake: String
  chargePointModel: String
  status: String
  suspended: Boolean
  hasToken: Boolean
  createdAt: DateTime
}

type UpsideDispatchMetaType {
  source: String
  location: String
}

type UpsideDispatchType {
  startDt: String
  endDt: String
  deltaKwh: Int
  source: String @deprecated(reason: "'source' has been moved under 'meta'. This field may now return null.")
  meta: UpsideDispatchMetaType
}

"""
Leverages the internal Python implmeentation of UUID (uuid.UUID) to provide native UUID objects
in fields, resolvers and input.
"""
scalar UUID

type ValidateBankAccount {
  bankName: String
  branch: String
  county: String
  line1: String
  line2: String
  line3: String
  line4: String
  town: String
  postcode: String
}

"""Validate whether a user's email is a valid email via the Kickbox API."""
type ValidateEmail {
  isValid: Boolean
}

"""Input required to validate email address via Kickbox"""
input ValidateEmailInput {
  """The user's email address"""
  email: String!
}

input VehicleChargingPreferencesInput {
  """Account number."""
  accountNumber: String!
  weekdayTargetTime: String!
  weekdayTargetSoc: Int!
  weekendTargetTime: String!
  weekendTargetSoc: Int!
  targetType: String
}

type VehicleChargingPreferencesType {
  weekdayTargetTime: String
  weekdayTargetSoc: Int
  weekendTargetTime: String
  weekendTargetSoc: Int
}

input VehicleInput {
  """The unique electric vehicle id."""
  vehicleId: Int!
}

type Verify {
  payload: GenericScalar!
}

type WanCoverageDetail {
  postcode: String
  addressIdentifier: String
  isCoverageAvailable: Boolean
  anticipatedCoverageAt: String
  wanTechnology: String
  auxiliaryEquipment: String
  connectivityLikelihood: String
  additionalInformation: String
}

"""An enumeration."""
enum WANCoverageStrengths {
  """WAN coverage for this postcode is high quality."""
  HIGH

  """WAN coverage for this postcode is medium quality."""
  MEDIUM

  """WAN coverage for this postcode is low quality."""
  LOW
}

type WarmHomeDiscount {
  """
  Get the Warm Home Discount applications against this account. These are ordered to return the most recent first.
  """
  applications(before: String, after: String, first: Int, last: Int): WarmHomeDiscountApplicationConnection

  """
  Get the Warm Home Discount records attached to this account. These are ordered to return the most recent first.
  """
  records(before: String, after: String, first: Int, last: Int): WarmHomeDiscountRecordConnection
}

"""Get details about a Warm Home Discount application."""
type WarmHomeDiscountApplication {
  """Which criteria was chosen for the Warm Home Discount application"""
  qualifyingCriteria: QualifyingCriteriaOptions

  """
  Which component criteria was chosen for the Warm Home Discount application
  """
  qualifyingComponent: QualifyingComponentOptions

  """The status of the Warm Home Discount application"""
  status: Status

  """Reason for rejecting a Warm Home Discount application"""
  rejectionReason: RejectionReason

  """The tax year for which the application was made."""
  taxYear: String

  """The last date on which this application was updated."""
  updatedAt: Date
}

"""


This field is a connection type. Connections are used to implement [cursor based
pagination](https://graphql.org/learn/pagination/#pagination-and-edges).


"""
type WarmHomeDiscountApplicationConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [WarmHomeDiscountApplicationEdge]!
}

"""
A Relay edge containing a `WarmHomeDiscountApplication` and its cursor.
"""
type WarmHomeDiscountApplicationEdge {
  """The item at the end of the edge"""
  node: WarmHomeDiscountApplication

  """A cursor for use in pagination"""
  cursor: String!
}

input WarmHomeDiscountApplicationInputType {
  """
  A set of criteria under which someone is eligible for the Warm Home Discount.
  The applicant must meet at least one of these criteria, as well as at least
  one qualifying component criteria.
  """
  qualifyingCriteria: QualifyingCriteriaOptions

  """
  A set of criteria under which someone is eligible for the Warm Home Discount.
  The applicant must meet at least one of these criteria, as well as at least
  one qualifying component criteria.
  """
  qualifyingComponent: QualifyingComponentOptions
}

type WarmHomeDiscountApplicationOutputType {
  errors: [SerializerFieldErrorsType]
  id: String
}

"""Get details about a Warm Home Discount record."""
type WarmHomeDiscountRecord {
  """
  Type of account receiving the discount. Either credit the account or payment via prepay cards
  """
  accountType: WhdAccountType

  """should be in the format YYYY/YY e.g. 2019/20"""
  taxYear: String!

  """Which criteria was chosen for the Warm Home Discount."""
  qualifyingCriteria: QualifyingCriteriaOptions

  """Which component criteria was chosen for the Warm Home Discount."""
  qualifyingComponent: QualifyingComponentOptions

  """
  Amount in pence that was credited to the account as a result of the discount.
  """
  credit: Int
}

"""


This field is a connection type. Connections are used to implement [cursor based
pagination](https://graphql.org/learn/pagination/#pagination-and-edges).


"""
type WarmHomeDiscountRecordConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [WarmHomeDiscountRecordEdge]!
}

"""A Relay edge containing a `WarmHomeDiscountRecord` and its cursor."""
type WarmHomeDiscountRecordEdge {
  """The item at the end of the edge"""
  node: WarmHomeDiscountRecord

  """A cursor for use in pagination"""
  cursor: String!
}

"""An enumeration."""
enum WhdAccountType {
  """Prepay"""
  PREPAY

  """Credit"""
  CREDIT
}

"""

    The winter workout challange lets the user choose a goal to
    aspire to reach when saving energy, this model contains the
    available goals.
    
"""
enum WinterWorkoutGoalChoices {
  FIVE
  TEN
  TWENTY
}

"""An enumeration."""
enum WinterWorkoutGoalGoal {
  """5 %"""
  FIVE

  """10 %"""
  TEN

  """20 %"""
  TWENTY
}

"""
Type representing the fields in the datalake for winter workout goal tracking.
"""
type WinterWorkoutGoalTrackingType {
  fullTrialEstimate: Int
  aqConsumptionDelta: Int
  actualConsumptionDelta: Int
  co2SavedKg: Int
  actualCostSavedPounds: Float
  hasReads: Boolean
  isValid: Boolean
  isReduction: Boolean
  percentageDiff: Float
  rank: Int
}

"""Type representing a winter workout goal tied to an account."""
type WinterWorkoutGoalType {
  goal: WinterWorkoutGoalGoal!
}

"""
Type representing the fields in the datalake for winter workout initial estimates.
"""
type WinterWorkoutInitialEstimatesType {
  estimatedConumption: Int
  targetConsumption5: Int
  targetCostSavings5: Float
  targetCo2Savings5: Int
  targetConsumption10: Int
  targetCostSavings10: Float
  targetCo2Savings10: Int
  targetConsumption20: Int
  targetCostSavings20: Float
  targetCo2Savings20: Int
}

"""Input type to validate input for WinterWorkoutTipType."""
input WinterWorkoutTipInputType {
  id: Int!
  suitable: Boolean!
  completed: Boolean!
}

"""Type representing the winter workout tips set for an account."""
type WinterWorkoutTipsType {
  tips: [WinterWorkoutTipType]
}

"""Type representing the structure of a winter workout tip."""
type WinterWorkoutTipType {
  id: Int
  suitable: Boolean
  completed: Boolean
}

